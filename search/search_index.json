{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Architecture Overview The Assets project is a full\u2011stack, peer\u2011to\u2011peer asset lending platform built with a modern open\u2011source stack. It demonstrates how to combine Next.js with Django\u202fNinja in a monorepo powered by TurboRepo . Users borrow and lend assets through ticket\u2011based requests, track balances via an integrated wallet, and handle payments using the Zarinpal gateway. Monorepo Layout The repository is organized as a monorepo using TurboRepo. Each folder at the root serves a distinct purpose: / (root) \u2502 \u251c\u2500 backend/ \u2013 Django project using Django Ninja for the API \u2502 \u251c\u2500 frontend/ \u2013 Next.js app using React and HeroUI for the UI \u2502 \u251c\u2500 packages/ \u2013 shared code (types, helpers) \u2502 \u251c\u2500 docs/ \u2013 project documentation \u2502 \u251c\u2500 mkdocs.yml \u2013 MkDocs configuration for documentation site \u2502 \u2514\u2500 \u2026 Having the server and client in one repository simplifies dependency management, encourages code sharing, and makes it easier to coordinate releases. Application Flow The following diagram illustrates the high\u2011level flow of a typical session: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 User \u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 Frontend \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 Backend \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 Database \u2502 \u2502 (Next.js) \u2502 \u2502 (Django) \u2502 \u2502 (Postgres) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u25b2 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u25bc \u2502 OAuth 2.0 / JWT Business logic Persistent data Authentication: Users log in using Auth0 (SSO) or email/password via OAuth\u202f2.0. Upon successful authentication, the frontend stores a short\u2011lived JWT in a secure cookie. Frontend: Built with Next.js and HeroUI, it provides dashboards, forms for ticket creation, and wallet management. It communicates with the backend via REST endpoints. Backend: Django + Django\u202fNinja expose a versioned API. Services include authentication, wallet operations, ticket lifecycle management, and reporting. Database: PostgreSQL stores users, roles, wallets, ledger entries, tickets, and audit logs. Row\u2011level security can be enabled for multi\u2011tenant scenarios. Payments: The backend integrates with Zarinpal for payment processing; future gateways can be added via an adapter pattern. Backend Architecture The backend folder contains a Django project configured with Django\u202fNinja. Each module is structured as an app: auth \u2013 handles OAuth\u202f2.0, email/password login, JWT issuance, and role management. wallet \u2013 manages user balances and ledger entries; interacts with payment providers. tickets \u2013 CRUD operations for loan requests and approvals; manages ticket statuses and SLA logic. reports \u2013 aggregates data for dashboards and exports (CSV, XLSX). The API is type\u2011hinted and auto\u2011documented via OpenAPI/Swagger, making it easy for developers to explore available endpoints. Database Schema (Key Tables) Table Description users User accounts, including SSO subject and role. wallets One wallet per user; tracks balance and currency. ledger_entries Double\u2011entry accounting for wallet transactions. tickets Asset lending requests with status and pricing. ticket_comments Comments and attachments associated with tickets. audit_logs Records of security\u2011sensitive actions. This schema is defined in Django models and managed via migrations. Seed data is provided to facilitate local development and testing. Request Lifecycle Example To illustrate how components work together, consider the flow of creating a ticket: Login: The user logs in via Auth0 (or email/password), receiving a JWT. Create Ticket: On the frontend, the user fills out a form specifying the asset, desired duration, and price. The form posts to POST /tickets/ . Backend Processing: Django Ninja validates the request, creates a Ticket record in Postgres, and emits a notification to the lender via SMS/WhatsApp and email. Lender Response: The lender accepts or declines via a PATCH endpoint; if accepted, the platform records a pending transaction. Payment & Ledger: Once both parties confirm, the wallet service debits the borrower\u2019s balance and credits the lender\u2019s. Ledger entries are written, and Zarinpal processes the external payment. Completion: At the end of the loan period, the ticket status is updated and funds are settled accordingly. Security Considerations Authentication & Authorization: OAuth\u202f2.0 and JWT ensure that only authenticated users can access protected routes. Role checks enforce permissions (admin vs user). Transport & Data Security: All traffic is served over HTTPS; sensitive data at rest is encrypted (e.g. AES for private keys). Passwords are hashed with modern algorithms like bcrypt. Rate Limiting: The API includes rate limiting and CSRF protection to mitigate abuse. Audit Logging: Administrative actions and wallet operations are logged for traceability. Extensibility & Deployment The project is intentionally modular: Adapters: Payment providers are abstracted behind interfaces; adding support for other gateways (Stripe, Coinbase) requires minimal changes. Services: Each domain (auth, wallet, tickets) can be extended independently, making it easy to introduce new features such as asset categories or escrow. DevOps: The repository includes Docker and CI/CD configurations (GitHub Actions). Deployments can target platforms like Vercel (frontend) and Render/Railway/Fly (backend).","title":"\ud83d\udcd8 Architecture"},{"location":"#architecture","text":"","title":"Architecture"},{"location":"#overview","text":"The Assets project is a full\u2011stack, peer\u2011to\u2011peer asset lending platform built with a modern open\u2011source stack. It demonstrates how to combine Next.js with Django\u202fNinja in a monorepo powered by TurboRepo . Users borrow and lend assets through ticket\u2011based requests, track balances via an integrated wallet, and handle payments using the Zarinpal gateway.","title":"Overview"},{"location":"#monorepo-layout","text":"The repository is organized as a monorepo using TurboRepo. Each folder at the root serves a distinct purpose: / (root) \u2502 \u251c\u2500 backend/ \u2013 Django project using Django Ninja for the API \u2502 \u251c\u2500 frontend/ \u2013 Next.js app using React and HeroUI for the UI \u2502 \u251c\u2500 packages/ \u2013 shared code (types, helpers) \u2502 \u251c\u2500 docs/ \u2013 project documentation \u2502 \u251c\u2500 mkdocs.yml \u2013 MkDocs configuration for documentation site \u2502 \u2514\u2500 \u2026 Having the server and client in one repository simplifies dependency management, encourages code sharing, and makes it easier to coordinate releases.","title":"Monorepo Layout"},{"location":"#application-flow","text":"The following diagram illustrates the high\u2011level flow of a typical session: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 User \u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 Frontend \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 Backend \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 Database \u2502 \u2502 (Next.js) \u2502 \u2502 (Django) \u2502 \u2502 (Postgres) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u25b2 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u25bc \u2502 OAuth 2.0 / JWT Business logic Persistent data Authentication: Users log in using Auth0 (SSO) or email/password via OAuth\u202f2.0. Upon successful authentication, the frontend stores a short\u2011lived JWT in a secure cookie. Frontend: Built with Next.js and HeroUI, it provides dashboards, forms for ticket creation, and wallet management. It communicates with the backend via REST endpoints. Backend: Django + Django\u202fNinja expose a versioned API. Services include authentication, wallet operations, ticket lifecycle management, and reporting. Database: PostgreSQL stores users, roles, wallets, ledger entries, tickets, and audit logs. Row\u2011level security can be enabled for multi\u2011tenant scenarios. Payments: The backend integrates with Zarinpal for payment processing; future gateways can be added via an adapter pattern.","title":"Application Flow"},{"location":"#backend-architecture","text":"The backend folder contains a Django project configured with Django\u202fNinja. Each module is structured as an app: auth \u2013 handles OAuth\u202f2.0, email/password login, JWT issuance, and role management. wallet \u2013 manages user balances and ledger entries; interacts with payment providers. tickets \u2013 CRUD operations for loan requests and approvals; manages ticket statuses and SLA logic. reports \u2013 aggregates data for dashboards and exports (CSV, XLSX). The API is type\u2011hinted and auto\u2011documented via OpenAPI/Swagger, making it easy for developers to explore available endpoints.","title":"Backend Architecture"},{"location":"#database-schema-key-tables","text":"Table Description users User accounts, including SSO subject and role. wallets One wallet per user; tracks balance and currency. ledger_entries Double\u2011entry accounting for wallet transactions. tickets Asset lending requests with status and pricing. ticket_comments Comments and attachments associated with tickets. audit_logs Records of security\u2011sensitive actions. This schema is defined in Django models and managed via migrations. Seed data is provided to facilitate local development and testing.","title":"Database Schema (Key Tables)"},{"location":"#request-lifecycle-example","text":"To illustrate how components work together, consider the flow of creating a ticket: Login: The user logs in via Auth0 (or email/password), receiving a JWT. Create Ticket: On the frontend, the user fills out a form specifying the asset, desired duration, and price. The form posts to POST /tickets/ . Backend Processing: Django Ninja validates the request, creates a Ticket record in Postgres, and emits a notification to the lender via SMS/WhatsApp and email. Lender Response: The lender accepts or declines via a PATCH endpoint; if accepted, the platform records a pending transaction. Payment & Ledger: Once both parties confirm, the wallet service debits the borrower\u2019s balance and credits the lender\u2019s. Ledger entries are written, and Zarinpal processes the external payment. Completion: At the end of the loan period, the ticket status is updated and funds are settled accordingly.","title":"Request Lifecycle Example"},{"location":"#security-considerations","text":"Authentication & Authorization: OAuth\u202f2.0 and JWT ensure that only authenticated users can access protected routes. Role checks enforce permissions (admin vs user). Transport & Data Security: All traffic is served over HTTPS; sensitive data at rest is encrypted (e.g. AES for private keys). Passwords are hashed with modern algorithms like bcrypt. Rate Limiting: The API includes rate limiting and CSRF protection to mitigate abuse. Audit Logging: Administrative actions and wallet operations are logged for traceability.","title":"Security Considerations"},{"location":"#extensibility-deployment","text":"The project is intentionally modular: Adapters: Payment providers are abstracted behind interfaces; adding support for other gateways (Stripe, Coinbase) requires minimal changes. Services: Each domain (auth, wallet, tickets) can be extended independently, making it easy to introduce new features such as asset categories or escrow. DevOps: The repository includes Docker and CI/CD configurations (GitHub Actions). Deployments can target platforms like Vercel (frontend) and Render/Railway/Fly (backend).","title":"Extensibility &amp; Deployment"},{"location":"api-reference/","text":"API Reference Overview This document provides the API reference for the Assets platform. All endpoints are implemented using Django Ninja and protected via JWT authentication with optional OAuth 2.0 integration. Base URL: https://{host}[:{port}]/api/v1/ Full Docs: {Base-URL}/docs/ Authentication POST /auth/login/ Authenticate user with email and password, returning JWT tokens. Request: { \"email\": \"user@example.com\", \"password\": \"yourpassword\" } Response: { \"access\": \"jwt_access_token\", \"refresh\": \"jwt_refresh_token\", \"user\": { \"id\": 1, \"email\": \"user@example.com\", \"role\": \"user\" } } POST /auth/refresh/ Refresh access token using a valid refresh token. Request: { \"refresh\": \"jwt_refresh_token\" } Response: { \"access\": \"new_jwt_access_token\" } Users GET /users/me/ Retrieve the authenticated user's profile. Response: { \"id\": 1, \"email\": \"user@example.com\", \"wallet_balance\": 250.0, \"role\": \"user\" } PATCH /users/me/ Update user's profile details. Request: { \"first_name\": \"Shahriyar\", \"last_name\": \"A.R.\" } Wallet GET /wallet/ Fetch wallet details and transaction history. Response: { \"wallet_id\": \"WAL123456\", \"balance\": 250.0, \"currency\": \"IRR\", \"transactions\": [ { \"id\": 1, \"type\": \"credit\", \"amount\": 100, \"timestamp\": \"2025-11-01T14:32:00Z\" }, { \"id\": 2, \"type\": \"debit\", \"amount\": 50, \"timestamp\": \"2025-11-02T09:10:00Z\" } ] } POST /wallet/transfer/ Transfer funds between users. Request: { \"recipient_id\": 5, \"amount\": 20.0 } Response: { \"status\": \"success\", \"transaction_id\": \"TX998877\" } Tickets GET /tickets/ List all user-related tickets. Response: [ { \"id\": 12, \"asset_name\": \"Canon EOS 5D\", \"status\": \"active\", \"price\": 120, \"lender\": \"alice@example.com\", \"borrower\": \"bob@example.com\" } ] POST /tickets/ Create a new asset lending request. Request: { \"asset_name\": \"Laptop Dell XPS 13\", \"price\": 150, \"duration_days\": 7 } Response: { \"id\": 15, \"status\": \"pending\", \"message\": \"Ticket created successfully.\" } PATCH /tickets/{ticket_id}/accept/ Accept a lending request (admin or lender only). Response: { \"id\": 15, \"status\": \"accepted\", \"message\": \"Ticket accepted and payment initiated.\" } Reports GET /reports/overview/ Get financial and activity reports for user or admin dashboards. Response: { \"total_users\": 500, \"total_tickets\": 1200, \"active_loans\": 450, \"total_volume\": 35000000 } Errors All endpoints return standardized error responses: Example: { \"detail\": \"Invalid token or session expired.\" } HTTP Code Meaning 200 Success 400 Bad Request 401 Unauthorized 403 Forbidden 404 Not Found 500 Server Error","title":"\ud83e\udde9 API Reference"},{"location":"api-reference/#api-reference","text":"","title":"API Reference"},{"location":"api-reference/#overview","text":"This document provides the API reference for the Assets platform. All endpoints are implemented using Django Ninja and protected via JWT authentication with optional OAuth 2.0 integration. Base URL: https://{host}[:{port}]/api/v1/ Full Docs: {Base-URL}/docs/","title":"Overview"},{"location":"api-reference/#authentication","text":"","title":"Authentication"},{"location":"api-reference/#post-authlogin","text":"Authenticate user with email and password, returning JWT tokens. Request: { \"email\": \"user@example.com\", \"password\": \"yourpassword\" } Response: { \"access\": \"jwt_access_token\", \"refresh\": \"jwt_refresh_token\", \"user\": { \"id\": 1, \"email\": \"user@example.com\", \"role\": \"user\" } }","title":"POST /auth/login/"},{"location":"api-reference/#post-authrefresh","text":"Refresh access token using a valid refresh token. Request: { \"refresh\": \"jwt_refresh_token\" } Response: { \"access\": \"new_jwt_access_token\" }","title":"POST /auth/refresh/"},{"location":"api-reference/#users","text":"","title":"Users"},{"location":"api-reference/#get-usersme","text":"Retrieve the authenticated user's profile. Response: { \"id\": 1, \"email\": \"user@example.com\", \"wallet_balance\": 250.0, \"role\": \"user\" }","title":"GET /users/me/"},{"location":"api-reference/#patch-usersme","text":"Update user's profile details. Request: { \"first_name\": \"Shahriyar\", \"last_name\": \"A.R.\" }","title":"PATCH /users/me/"},{"location":"api-reference/#wallet","text":"","title":"Wallet"},{"location":"api-reference/#get-wallet","text":"Fetch wallet details and transaction history. Response: { \"wallet_id\": \"WAL123456\", \"balance\": 250.0, \"currency\": \"IRR\", \"transactions\": [ { \"id\": 1, \"type\": \"credit\", \"amount\": 100, \"timestamp\": \"2025-11-01T14:32:00Z\" }, { \"id\": 2, \"type\": \"debit\", \"amount\": 50, \"timestamp\": \"2025-11-02T09:10:00Z\" } ] }","title":"GET /wallet/"},{"location":"api-reference/#post-wallettransfer","text":"Transfer funds between users. Request: { \"recipient_id\": 5, \"amount\": 20.0 } Response: { \"status\": \"success\", \"transaction_id\": \"TX998877\" }","title":"POST /wallet/transfer/"},{"location":"api-reference/#tickets","text":"","title":"Tickets"},{"location":"api-reference/#get-tickets","text":"List all user-related tickets. Response: [ { \"id\": 12, \"asset_name\": \"Canon EOS 5D\", \"status\": \"active\", \"price\": 120, \"lender\": \"alice@example.com\", \"borrower\": \"bob@example.com\" } ]","title":"GET /tickets/"},{"location":"api-reference/#post-tickets","text":"Create a new asset lending request. Request: { \"asset_name\": \"Laptop Dell XPS 13\", \"price\": 150, \"duration_days\": 7 } Response: { \"id\": 15, \"status\": \"pending\", \"message\": \"Ticket created successfully.\" }","title":"POST /tickets/"},{"location":"api-reference/#patch-ticketsticket_idaccept","text":"Accept a lending request (admin or lender only). Response: { \"id\": 15, \"status\": \"accepted\", \"message\": \"Ticket accepted and payment initiated.\" }","title":"PATCH /tickets/{ticket_id}/accept/"},{"location":"api-reference/#reports","text":"","title":"Reports"},{"location":"api-reference/#get-reportsoverview","text":"Get financial and activity reports for user or admin dashboards. Response: { \"total_users\": 500, \"total_tickets\": 1200, \"active_loans\": 450, \"total_volume\": 35000000 }","title":"GET /reports/overview/"},{"location":"api-reference/#errors","text":"All endpoints return standardized error responses: Example: { \"detail\": \"Invalid token or session expired.\" } HTTP Code Meaning 200 Success 400 Bad Request 401 Unauthorized 403 Forbidden 404 Not Found 500 Server Error","title":"Errors"},{"location":"auth-security/","text":"Auth & Security Overview This document outlines the authentication, authorization, and security standards implemented in the Assets platform. The system employs OAuth 2.0 , JWT-based session management , and strong encryption practices (AES-256, SHA-256) to safeguard user data and operations. Authentication Flow 1. Login Users can authenticate using email/password or OAuth 2.0 (SSO) providers. Upon successful authentication, the server issues a JWT access token and a refresh token . Tokens are stored in HttpOnly cookies to prevent JavaScript access. 2. Token Refresh The frontend periodically refreshes tokens using the /auth/refresh/ endpoint before expiration. Refresh tokens have a longer lifespan but can be revoked on logout or anomaly detection. 3. Logout Logout invalidates the refresh token on the server side and clears cookies in the client browser. 4. OAuth 2.0 / SSO The platform supports external identity providers such as Google , GitHub , and Auth0 . The backend validates the external provider\u2019s token and issues local JWTs for API access. OAuth flow: Client \u2192 Provider Auth \u2192 Redirect \u2192 Token Exchange \u2192 JWT issued . Authorization Role Permissions Admin Full access to manage users, tickets, reports, and wallets. User Can create and manage personal tickets, view wallet and transaction history. Authorization is enforced via Django Ninja dependency injection and role-based decorators . Sensitive endpoints (wallet updates, ticket actions) are double-checked with permission guards. Password Management User passwords are stored using bcrypt hashing. Password reset requests generate short-lived signed tokens with expiration limits. Login attempts are rate-limited by IP and user to prevent brute-force attacks. Encryption Standards Context Algorithm Usage Data in Transit TLS 1.3 HTTPS between client and server Data at Rest AES-256-GCM Encrypts wallet and personal data Password Hashing bcrypt Stores secure salted hashes Integrity Check SHA-256 Verifies file and data integrity All sensitive keys and secrets are managed through environment variables. The backend supports automatic key rotation using versioned secrets. Session Security HttpOnly and Secure flags are set on cookies. CSRF protection is enforced for browser-based requests. CORS is limited to trusted frontend domains. Session timeouts and idle logout are configurable per role. Payment Security (Zarinpal) Zarinpal API keys are stored securely via environment variables. All payment callbacks are verified with Zarinpal\u2019s checksum signature. Transactions use HMAC-SHA256 signatures for request validation. Wallet operations are atomic transactions to prevent double-spend conditions. Audit Logging Every sensitive operation is logged with: Timestamp and user ID Request IP and method Entity affected (ticket, wallet, user) Action outcome (success/failure) Logs are immutable and periodically exported to an archival storage system. Security Testing Test Type Tools Description Static Analysis Bandit, Ruff Scans Python code for vulnerabilities Dependency Audit Safety Checks for known CVEs in libraries Penetration Testing OWASP ZAP Simulates common attacks (XSS, CSRF, SQLi) Load Testing Locust Evaluates performance under concurrent access Compliance and Best Practices GDPR-aligned data handling and deletion workflows. Encryption keys and tokens never committed to version control. Security patches and dependencies updated via automated CI pipelines. Regular backup rotation and integrity checks. Incident Response Detect \u2192 Monitor logs and alerts for anomalies. Contain \u2192 Disable affected tokens, isolate endpoints. Eradicate \u2192 Patch vulnerabilities and rotate secrets. Recover \u2192 Restore service and notify stakeholders. Review \u2192 Conduct post-mortem and update policies.","title":"\ud83d\udd10 Auth & Security"},{"location":"auth-security/#auth-security","text":"","title":"Auth &amp; Security"},{"location":"auth-security/#overview","text":"This document outlines the authentication, authorization, and security standards implemented in the Assets platform. The system employs OAuth 2.0 , JWT-based session management , and strong encryption practices (AES-256, SHA-256) to safeguard user data and operations.","title":"Overview"},{"location":"auth-security/#authentication-flow","text":"","title":"Authentication Flow"},{"location":"auth-security/#1-login","text":"Users can authenticate using email/password or OAuth 2.0 (SSO) providers. Upon successful authentication, the server issues a JWT access token and a refresh token . Tokens are stored in HttpOnly cookies to prevent JavaScript access.","title":"1. Login"},{"location":"auth-security/#2-token-refresh","text":"The frontend periodically refreshes tokens using the /auth/refresh/ endpoint before expiration. Refresh tokens have a longer lifespan but can be revoked on logout or anomaly detection.","title":"2. Token Refresh"},{"location":"auth-security/#3-logout","text":"Logout invalidates the refresh token on the server side and clears cookies in the client browser.","title":"3. Logout"},{"location":"auth-security/#4-oauth-20-sso","text":"The platform supports external identity providers such as Google , GitHub , and Auth0 . The backend validates the external provider\u2019s token and issues local JWTs for API access. OAuth flow: Client \u2192 Provider Auth \u2192 Redirect \u2192 Token Exchange \u2192 JWT issued .","title":"4. OAuth 2.0 / SSO"},{"location":"auth-security/#authorization","text":"Role Permissions Admin Full access to manage users, tickets, reports, and wallets. User Can create and manage personal tickets, view wallet and transaction history. Authorization is enforced via Django Ninja dependency injection and role-based decorators . Sensitive endpoints (wallet updates, ticket actions) are double-checked with permission guards.","title":"Authorization"},{"location":"auth-security/#password-management","text":"User passwords are stored using bcrypt hashing. Password reset requests generate short-lived signed tokens with expiration limits. Login attempts are rate-limited by IP and user to prevent brute-force attacks.","title":"Password Management"},{"location":"auth-security/#encryption-standards","text":"Context Algorithm Usage Data in Transit TLS 1.3 HTTPS between client and server Data at Rest AES-256-GCM Encrypts wallet and personal data Password Hashing bcrypt Stores secure salted hashes Integrity Check SHA-256 Verifies file and data integrity All sensitive keys and secrets are managed through environment variables. The backend supports automatic key rotation using versioned secrets.","title":"Encryption Standards"},{"location":"auth-security/#session-security","text":"HttpOnly and Secure flags are set on cookies. CSRF protection is enforced for browser-based requests. CORS is limited to trusted frontend domains. Session timeouts and idle logout are configurable per role.","title":"Session Security"},{"location":"auth-security/#payment-security-zarinpal","text":"Zarinpal API keys are stored securely via environment variables. All payment callbacks are verified with Zarinpal\u2019s checksum signature. Transactions use HMAC-SHA256 signatures for request validation. Wallet operations are atomic transactions to prevent double-spend conditions.","title":"Payment Security (Zarinpal)"},{"location":"auth-security/#audit-logging","text":"Every sensitive operation is logged with: Timestamp and user ID Request IP and method Entity affected (ticket, wallet, user) Action outcome (success/failure) Logs are immutable and periodically exported to an archival storage system.","title":"Audit Logging"},{"location":"auth-security/#security-testing","text":"Test Type Tools Description Static Analysis Bandit, Ruff Scans Python code for vulnerabilities Dependency Audit Safety Checks for known CVEs in libraries Penetration Testing OWASP ZAP Simulates common attacks (XSS, CSRF, SQLi) Load Testing Locust Evaluates performance under concurrent access","title":"Security Testing"},{"location":"auth-security/#compliance-and-best-practices","text":"GDPR-aligned data handling and deletion workflows. Encryption keys and tokens never committed to version control. Security patches and dependencies updated via automated CI pipelines. Regular backup rotation and integrity checks.","title":"Compliance and Best Practices"},{"location":"auth-security/#incident-response","text":"Detect \u2192 Monitor logs and alerts for anomalies. Contain \u2192 Disable affected tokens, isolate endpoints. Eradicate \u2192 Patch vulnerabilities and rotate secrets. Recover \u2192 Restore service and notify stakeholders. Review \u2192 Conduct post-mortem and update policies.","title":"Incident Response"},{"location":"backend/","text":"Backend Overview The Assets backend is built using Django and Django Ninja , providing a clean, secure, and scalable API foundation. It handles authentication, wallet management, ticket operations, payment integration, and reporting. The backend adheres to RESTful principles and integrates seamlessly with the Next.js frontend. Tech Stack Category Technology Purpose Framework Django Core backend and ORM API Layer Django Ninja 1.4.x Fast type-safe REST API using Pydantic models Database PostgreSQL Relational storage with strong ACID guarantees Auth JWT + OAuth 2.0 Secure authentication and SSO support Testing PyTest, Django Test Client Automated unit and integration testing Caching Redis Session and rate-limit caching Task Queue Celery Background jobs and notifications Deployment GHCR Easy deployment Security AES-256, SHA-256, HTTPS Encryption and integrity Project Structure backend/ \u251c\u2500\u2500 assets_backend/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 settings.py # Environment configs, middleware, installed apps \u2502 \u251c\u2500\u2500 urls.py # Root routing configuration \u2502 \u251c\u2500\u2500 asgi.py / wsgi.py # Server entry points \u2502 \u2514\u2500\u2500 schema.py # OpenAPI schema (generated by Django Ninja) \u2502 \u251c\u2500\u2500 apps/ \u2502 \u251c\u2500\u2500 auth/ # Authentication and OAuth modules \u2502 \u251c\u2500\u2500 wallet/ # Wallet + ledger management \u2502 \u251c\u2500\u2500 tickets/ # Asset lending and ticket lifecycle \u2502 \u251c\u2500\u2500 payments/ # Zarinpal integration \u2502 \u251c\u2500\u2500 reports/ # Dashboards and analytics \u2502 \u2514\u2500\u2500 notifications/ # SMS, WhatsApp, email integration \u2502 \u251c\u2500\u2500 tests/ \u2502 \u251c\u2500\u2500 conftest.py \u2502 \u251c\u2500\u2500 test_auth.py \u2502 \u251c\u2500\u2500 test_wallet.py \u2502 \u2514\u2500\u2500 test_tickets.py \u2502 \u251c\u2500\u2500 requirements.txt \u251c\u2500\u2500 manage.py \u2514\u2500\u2500 Dockerfile App Overview App Description auth Handles JWT, OAuth 2.0, and user management. wallet Implements user wallets and double-entry ledger system. tickets Core of the lending workflow (requests, approvals, lifecycle). payments Integrates Zarinpal payment gateway and verification. reports Aggregates data for dashboards and analytics. notifications Sends SMS/WhatsApp/email updates. Authentication & Authorization JWT Authentication Access and refresh tokens issued via /auth/login/ . Stored securely as HttpOnly cookies. Token rotation and blacklist enabled via Django cache. OAuth 2.0 Supports third-party providers such as: Google GitHub Auth0 Upon OAuth login, the backend maps user profiles and issues JWTs. Wallet System Implements double-entry accounting to ensure transaction accuracy. Action Debit Credit Deposit Bank Account Wallet Transfer Sender Wallet Receiver Wallet Payment Wallet Ticket Escrow All transactions are atomic and auditable via ledger_entries . Example model snippet: class LedgerEntry(models.Model): wallet = models.ForeignKey(\"Wallet\", on_delete=models.CASCADE) type = models.CharField(choices=[(\"credit\", \"Credit\"), (\"debit\", \"Debit\")]) amount = models.DecimalField(max_digits=18, decimal_places=2) ref = models.CharField(max_length=64, null=True, blank=True) description = models.TextField(blank=True) created_at = models.DateTimeField(auto_now_add=True) Tickets Module Manages the end-to-end asset lending workflow. Status Description pending Awaiting lender approval accepted Approved, awaiting payment active Payment verified, loan ongoing completed Loan duration ended successfully cancelled Request withdrawn or expired Example API endpoints: GET /tickets/ \u2014 List user tickets POST /tickets/ \u2014 Create new lending request PATCH /tickets/{id}/accept/ \u2014 Approve a ticket PATCH /tickets/{id}/complete/ \u2014 Mark as completed Payments Module (Zarinpal) Zarinpal integration ensures secure, traceable payments. Initiates payment on wallet recharge. Verifies transaction via callback from Zarinpal API. Updates wallet balances upon confirmation. Example flow: Create payment \u2192 /payments/initiate/ Redirect user to Zarinpal gateway Verify callback \u2192 /payments/verify/ Update payments and ledger_entries Reports Module Generates real-time and aggregated insights for dashboards. Metric Description total_users Total registered users active_loans Currently active lending transactions total_volume Total monetary transaction volume daily_activity Recent user actions summary Data is aggregated nightly using a Celery task (optional). Notifications System Supports multiple channels: SMS and WhatsApp (via API adapters) Email via Postmark or SendGrid Each notification is logged in the database with delivery status. Example schema: class Notification(models.Model): user = models.ForeignKey(User, on_delete=models.CASCADE) channel = models.CharField(choices=[(\"sms\", \"SMS\"), (\"email\", \"Email\"), (\"whatsapp\", \"WhatsApp\")]) message = models.TextField() status = models.CharField(choices=[(\"queued\", \"Queued\"), (\"sent\", \"Sent\"), (\"failed\", \"Failed\")]) created_at = models.DateTimeField(auto_now_add=True) Testing Type Tool Scope Unit PyTest Models and utilities Integration Django Test Client API endpoints E2E Playwright (Frontend) Combined frontend-backend flows Example command: pytest -v --maxfail=1 --disable-warnings Deployment Environment Variables SECRET_KEY=your_django_secret DATABASE_URL=postgresql://user:pass@localhost:5432/assets ZARINPAL_MERCHANT_ID=your_merchant_id ZARINPAL_CALLBACK_URL=https://api.assets.example.com/api/v1/payments/verify/ JWT_SECRET=supersecret DEBUG=False ALLOWED_HOSTS=assets.example.com Docker Setup docker build -t assets-backend . docker run -p 8000:8000 assets-backend Migrations python manage.py makemigrations python manage.py migrate Performance Optimization Use select_related and prefetch_related to reduce query count. Add PostgreSQL indexes on foreign keys and frequently queried fields. Cache API responses for frequent reads. Configure Gunicorn workers for concurrency. Security Checklist Enforce HTTPS and secure cookies. Rotate JWT and refresh tokens periodically. Encrypt sensitive user data (AES-256). Use Django\u2019s built-in CSRF protection. Regular vulnerability scans and dependency updates. Enable rate limiting and IP throttling.","title":"\u2699\ufe0f Backend"},{"location":"backend/#backend","text":"","title":"Backend"},{"location":"backend/#overview","text":"The Assets backend is built using Django and Django Ninja , providing a clean, secure, and scalable API foundation. It handles authentication, wallet management, ticket operations, payment integration, and reporting. The backend adheres to RESTful principles and integrates seamlessly with the Next.js frontend.","title":"Overview"},{"location":"backend/#tech-stack","text":"Category Technology Purpose Framework Django Core backend and ORM API Layer Django Ninja 1.4.x Fast type-safe REST API using Pydantic models Database PostgreSQL Relational storage with strong ACID guarantees Auth JWT + OAuth 2.0 Secure authentication and SSO support Testing PyTest, Django Test Client Automated unit and integration testing Caching Redis Session and rate-limit caching Task Queue Celery Background jobs and notifications Deployment GHCR Easy deployment Security AES-256, SHA-256, HTTPS Encryption and integrity","title":"Tech Stack"},{"location":"backend/#project-structure","text":"backend/ \u251c\u2500\u2500 assets_backend/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 settings.py # Environment configs, middleware, installed apps \u2502 \u251c\u2500\u2500 urls.py # Root routing configuration \u2502 \u251c\u2500\u2500 asgi.py / wsgi.py # Server entry points \u2502 \u2514\u2500\u2500 schema.py # OpenAPI schema (generated by Django Ninja) \u2502 \u251c\u2500\u2500 apps/ \u2502 \u251c\u2500\u2500 auth/ # Authentication and OAuth modules \u2502 \u251c\u2500\u2500 wallet/ # Wallet + ledger management \u2502 \u251c\u2500\u2500 tickets/ # Asset lending and ticket lifecycle \u2502 \u251c\u2500\u2500 payments/ # Zarinpal integration \u2502 \u251c\u2500\u2500 reports/ # Dashboards and analytics \u2502 \u2514\u2500\u2500 notifications/ # SMS, WhatsApp, email integration \u2502 \u251c\u2500\u2500 tests/ \u2502 \u251c\u2500\u2500 conftest.py \u2502 \u251c\u2500\u2500 test_auth.py \u2502 \u251c\u2500\u2500 test_wallet.py \u2502 \u2514\u2500\u2500 test_tickets.py \u2502 \u251c\u2500\u2500 requirements.txt \u251c\u2500\u2500 manage.py \u2514\u2500\u2500 Dockerfile","title":"Project Structure"},{"location":"backend/#app-overview","text":"App Description auth Handles JWT, OAuth 2.0, and user management. wallet Implements user wallets and double-entry ledger system. tickets Core of the lending workflow (requests, approvals, lifecycle). payments Integrates Zarinpal payment gateway and verification. reports Aggregates data for dashboards and analytics. notifications Sends SMS/WhatsApp/email updates.","title":"App Overview"},{"location":"backend/#authentication-authorization","text":"","title":"Authentication &amp; Authorization"},{"location":"backend/#jwt-authentication","text":"Access and refresh tokens issued via /auth/login/ . Stored securely as HttpOnly cookies. Token rotation and blacklist enabled via Django cache.","title":"JWT Authentication"},{"location":"backend/#oauth-20","text":"Supports third-party providers such as: Google GitHub Auth0 Upon OAuth login, the backend maps user profiles and issues JWTs.","title":"OAuth 2.0"},{"location":"backend/#wallet-system","text":"Implements double-entry accounting to ensure transaction accuracy. Action Debit Credit Deposit Bank Account Wallet Transfer Sender Wallet Receiver Wallet Payment Wallet Ticket Escrow All transactions are atomic and auditable via ledger_entries . Example model snippet: class LedgerEntry(models.Model): wallet = models.ForeignKey(\"Wallet\", on_delete=models.CASCADE) type = models.CharField(choices=[(\"credit\", \"Credit\"), (\"debit\", \"Debit\")]) amount = models.DecimalField(max_digits=18, decimal_places=2) ref = models.CharField(max_length=64, null=True, blank=True) description = models.TextField(blank=True) created_at = models.DateTimeField(auto_now_add=True)","title":"Wallet System"},{"location":"backend/#tickets-module","text":"Manages the end-to-end asset lending workflow. Status Description pending Awaiting lender approval accepted Approved, awaiting payment active Payment verified, loan ongoing completed Loan duration ended successfully cancelled Request withdrawn or expired Example API endpoints: GET /tickets/ \u2014 List user tickets POST /tickets/ \u2014 Create new lending request PATCH /tickets/{id}/accept/ \u2014 Approve a ticket PATCH /tickets/{id}/complete/ \u2014 Mark as completed","title":"Tickets Module"},{"location":"backend/#payments-module-zarinpal","text":"Zarinpal integration ensures secure, traceable payments. Initiates payment on wallet recharge. Verifies transaction via callback from Zarinpal API. Updates wallet balances upon confirmation. Example flow: Create payment \u2192 /payments/initiate/ Redirect user to Zarinpal gateway Verify callback \u2192 /payments/verify/ Update payments and ledger_entries","title":"Payments Module (Zarinpal)"},{"location":"backend/#reports-module","text":"Generates real-time and aggregated insights for dashboards. Metric Description total_users Total registered users active_loans Currently active lending transactions total_volume Total monetary transaction volume daily_activity Recent user actions summary Data is aggregated nightly using a Celery task (optional).","title":"Reports Module"},{"location":"backend/#notifications-system","text":"Supports multiple channels: SMS and WhatsApp (via API adapters) Email via Postmark or SendGrid Each notification is logged in the database with delivery status. Example schema: class Notification(models.Model): user = models.ForeignKey(User, on_delete=models.CASCADE) channel = models.CharField(choices=[(\"sms\", \"SMS\"), (\"email\", \"Email\"), (\"whatsapp\", \"WhatsApp\")]) message = models.TextField() status = models.CharField(choices=[(\"queued\", \"Queued\"), (\"sent\", \"Sent\"), (\"failed\", \"Failed\")]) created_at = models.DateTimeField(auto_now_add=True)","title":"Notifications System"},{"location":"backend/#testing","text":"Type Tool Scope Unit PyTest Models and utilities Integration Django Test Client API endpoints E2E Playwright (Frontend) Combined frontend-backend flows Example command: pytest -v --maxfail=1 --disable-warnings","title":"Testing"},{"location":"backend/#deployment","text":"","title":"Deployment"},{"location":"backend/#environment-variables","text":"SECRET_KEY=your_django_secret DATABASE_URL=postgresql://user:pass@localhost:5432/assets ZARINPAL_MERCHANT_ID=your_merchant_id ZARINPAL_CALLBACK_URL=https://api.assets.example.com/api/v1/payments/verify/ JWT_SECRET=supersecret DEBUG=False ALLOWED_HOSTS=assets.example.com","title":"Environment Variables"},{"location":"backend/#docker-setup","text":"docker build -t assets-backend . docker run -p 8000:8000 assets-backend","title":"Docker Setup"},{"location":"backend/#migrations","text":"python manage.py makemigrations python manage.py migrate","title":"Migrations"},{"location":"backend/#performance-optimization","text":"Use select_related and prefetch_related to reduce query count. Add PostgreSQL indexes on foreign keys and frequently queried fields. Cache API responses for frequent reads. Configure Gunicorn workers for concurrency.","title":"Performance Optimization"},{"location":"backend/#security-checklist","text":"Enforce HTTPS and secure cookies. Rotate JWT and refresh tokens periodically. Encrypt sensitive user data (AES-256). Use Django\u2019s built-in CSRF protection. Regular vulnerability scans and dependency updates. Enable rate limiting and IP throttling.","title":"Security Checklist"},{"location":"dashboards-reporting/","text":"Dashboards & Reporting Overview The Assets platform provides interactive dashboards and analytical reports to give users and administrators real-time insights into system activity. This page describes how reporting data is collected, processed, and visualized within both the frontend (Next.js + Recharts) and backend (Django + Ninja) systems. Goals Provide real-time visibility into user activity and transactions. Offer role-based dashboards for users and admins. Generate financial and operational reports for audits. Enable data aggregation and trend analysis over time. Dashboard Types Dashboard Audience Description User Dashboard Regular Users Displays wallet balance, ticket history, and activity summary. Admin Dashboard Administrators Monitors global metrics, financial summaries, and system logs. Reports Dashboard Management Aggregated analytics with exportable reports. Data Sources Dashboards pull data from multiple backend services and tables: Source Description wallets Tracks user balances and transactions. tickets Stores asset lending and borrowing activity. payments Logs verified transactions from Zarinpal. reports Pre-aggregated daily metrics for performance. notifications Logs of user alerts and message statuses. Backend Architecture The backend reporting engine is implemented under the reports app. Key Modules: | Module | Description | |------------------|------------------------------------------------------------------| | models.py | Defines the Report and AnalyticsRecord models. | | tasks.py | Handles nightly aggregation jobs. | | views.py | Exposes /reports/overview/ and /reports/metrics/ endpoints. | | serializers.py | Converts report objects to JSON format for the frontend. | Aggregation Process Reports are generated through a combination of scheduled jobs and on-demand API requests. Key Metrics Displayed Metric Description Total Users Registered users in the system. Active Loans Number of ongoing lending agreements. Total Tickets All tickets created to date. Total Volume Total IRR volume processed through payments. Wallet Balances Aggregate sum of all user wallet balances. Admin Dashboard Features Data Overview Cards: Display total users, loans, and revenue. Ticket Monitoring: Active vs. completed ticket ratio. Revenue Analysis: Daily and monthly transaction trends. Export Reports: CSV and PDF export for financial audits. Filters: Time range, asset type, or user segment filters. Exports & Integrations Reports can be exported or shared via integrations. Format Usage CSV Data export for analysis in spreadsheets. PDF Printable summaries for stakeholders. API JSON output for integrations or third-party analytics tools. Performance Considerations Reports are cached in Redis for fast retrieval. Heavy queries are executed asynchronously. Charts and tables use lazy loading and pagination. Indexes on report_date and status fields improve query speed. Security & Access Control Role Access Level Admin Full access to all reports and analytics. User Access limited to their own statistics. Auditor (future) Read-only access to financial reports. Reports are served via authenticated endpoints with JWT and role-based access control (RBAC) . Future Enhancements Real-time updates using WebSockets. Predictive analytics using historical data. Interactive filtering with drill-down reports. Multi-currency and regional reporting support. AI-driven anomaly detection for transactions.","title":"\ud83d\udcc8 Dashboards & Reporting"},{"location":"dashboards-reporting/#dashboards-reporting","text":"","title":"Dashboards &amp; Reporting"},{"location":"dashboards-reporting/#overview","text":"The Assets platform provides interactive dashboards and analytical reports to give users and administrators real-time insights into system activity. This page describes how reporting data is collected, processed, and visualized within both the frontend (Next.js + Recharts) and backend (Django + Ninja) systems.","title":"Overview"},{"location":"dashboards-reporting/#goals","text":"Provide real-time visibility into user activity and transactions. Offer role-based dashboards for users and admins. Generate financial and operational reports for audits. Enable data aggregation and trend analysis over time.","title":"Goals"},{"location":"dashboards-reporting/#dashboard-types","text":"Dashboard Audience Description User Dashboard Regular Users Displays wallet balance, ticket history, and activity summary. Admin Dashboard Administrators Monitors global metrics, financial summaries, and system logs. Reports Dashboard Management Aggregated analytics with exportable reports.","title":"Dashboard Types"},{"location":"dashboards-reporting/#data-sources","text":"Dashboards pull data from multiple backend services and tables: Source Description wallets Tracks user balances and transactions. tickets Stores asset lending and borrowing activity. payments Logs verified transactions from Zarinpal. reports Pre-aggregated daily metrics for performance. notifications Logs of user alerts and message statuses.","title":"Data Sources"},{"location":"dashboards-reporting/#backend-architecture","text":"The backend reporting engine is implemented under the reports app. Key Modules: | Module | Description | |------------------|------------------------------------------------------------------| | models.py | Defines the Report and AnalyticsRecord models. | | tasks.py | Handles nightly aggregation jobs. | | views.py | Exposes /reports/overview/ and /reports/metrics/ endpoints. | | serializers.py | Converts report objects to JSON format for the frontend. |","title":"Backend Architecture"},{"location":"dashboards-reporting/#aggregation-process","text":"Reports are generated through a combination of scheduled jobs and on-demand API requests.","title":"Aggregation Process"},{"location":"dashboards-reporting/#key-metrics-displayed","text":"Metric Description Total Users Registered users in the system. Active Loans Number of ongoing lending agreements. Total Tickets All tickets created to date. Total Volume Total IRR volume processed through payments. Wallet Balances Aggregate sum of all user wallet balances.","title":"Key Metrics Displayed"},{"location":"dashboards-reporting/#admin-dashboard-features","text":"Data Overview Cards: Display total users, loans, and revenue. Ticket Monitoring: Active vs. completed ticket ratio. Revenue Analysis: Daily and monthly transaction trends. Export Reports: CSV and PDF export for financial audits. Filters: Time range, asset type, or user segment filters.","title":"Admin Dashboard Features"},{"location":"dashboards-reporting/#exports-integrations","text":"Reports can be exported or shared via integrations. Format Usage CSV Data export for analysis in spreadsheets. PDF Printable summaries for stakeholders. API JSON output for integrations or third-party analytics tools.","title":"Exports &amp; Integrations"},{"location":"dashboards-reporting/#performance-considerations","text":"Reports are cached in Redis for fast retrieval. Heavy queries are executed asynchronously. Charts and tables use lazy loading and pagination. Indexes on report_date and status fields improve query speed.","title":"Performance Considerations"},{"location":"dashboards-reporting/#security-access-control","text":"Role Access Level Admin Full access to all reports and analytics. User Access limited to their own statistics. Auditor (future) Read-only access to financial reports. Reports are served via authenticated endpoints with JWT and role-based access control (RBAC) .","title":"Security &amp; Access Control"},{"location":"dashboards-reporting/#future-enhancements","text":"Real-time updates using WebSockets. Predictive analytics using historical data. Interactive filtering with drill-down reports. Multi-currency and regional reporting support. AI-driven anomaly detection for transactions.","title":"Future Enhancements"},{"location":"database-schema/","text":"Database Schema Documentation Overview This document defines the database schema for the Assets platform. It outlines all major tables, relationships, constraints, and indexing strategies. The platform uses PostgreSQL as the relational database engine, ensuring ACID compliance, foreign key integrity, and high scalability. Core Design Principles Normalization: Third Normal Form (3NF) to reduce redundancy. Auditability: All wallet and ticket operations are logged. Security: Role-based access and Row-Level Security (RLS). Extensibility: Modular tables to support new features such as asset categories or payment gateways. Integrity: Foreign keys, constraints, and cascade rules ensure consistent data. Entity Relationship Diagram (ERD) \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 users \u2502\u2500\u2500\u2510 \u2502 tickets \u2502\u2500\u2500\u2510 \u2502 payments \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u25bc \u25bc \u25bc \u25bc \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 wallets \u2502 \u2502 ledger_entry \u2502 \u2502 reports \u2502 \u2502 notifications\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Table Definitions 1. users Stores registered user accounts and identity provider metadata. Column Type Constraints Description id SERIAL PK Unique user ID email VARCHAR(255) UNIQUE, NOT NULL Primary user identifier password VARCHAR(255) NULLABLE Encrypted password (for non-SSO users) first_name VARCHAR(100) User\u2019s first name last_name VARCHAR(100) User\u2019s last name role ENUM('admin','user') DEFAULT 'user' Role-based permissions sso_provider VARCHAR(50) OAuth2 provider name sso_sub VARCHAR(255) External provider subject ID created_at TIMESTAMP DEFAULT now() Creation timestamp updated_at TIMESTAMP DEFAULT now() Last profile update Indexes: idx_users_email for quick lookups. Unique composite index on (sso_provider, sso_sub) for federated users. 2. wallets Each user owns one wallet, holding their balance in IRR (Rials). Column Type Constraints Description id SERIAL PK Wallet ID user_id INT FK \u2192 users.id Wallet owner balance NUMERIC(18,2) DEFAULT 0 Current balance currency VARCHAR(10) DEFAULT 'IRR' Currency code status ENUM('active','frozen') DEFAULT 'active' Wallet state created_at TIMESTAMP DEFAULT now() Creation timestamp Constraints: One wallet per user (UNIQUE user_id ). Indexes: idx_wallets_user for fast joins. 3. ledger_entries Records every financial transaction for audit purposes (double-entry system). Column Type Constraints Description id SERIAL PK Ledger record ID wallet_id INT FK \u2192 wallets.id Related wallet type ENUM('credit','debit') Transaction direction amount NUMERIC(18,2) CHECK (amount > 0) Transaction amount ref VARCHAR(64) External reference (Zarinpal Ref ID) description TEXT Human-readable info created_at TIMESTAMP DEFAULT now() Time of entry created_by INT FK \u2192 users.id Who triggered it Indexes: idx_ledger_wallet on wallet_id . idx_ledger_ref for reconciliation with payment gateway. 4. tickets Handles asset lending requests and agreements. Column Type Constraints Description id SERIAL PK Ticket ID asset_name VARCHAR(255) NOT NULL Asset name or description borrower_id INT FK \u2192 users.id Borrower user lender_id INT FK \u2192 users.id Lender user price NUMERIC(18,2) Agreed rental price duration_days INT Duration of lending status ENUM('pending','accepted','active','completed','cancelled') DEFAULT 'pending' Ticket state created_at TIMESTAMP DEFAULT now() Creation timestamp updated_at TIMESTAMP DEFAULT now() Status change timestamp Indexes: idx_tickets_borrower_lender idx_tickets_status for admin dashboards. 5. payments Tracks transactions made through Zarinpal. Column Type Constraints Description id SERIAL PK Payment record ID ticket_id INT FK \u2192 tickets.id Related ticket authority VARCHAR(64) UNIQUE Zarinpal authority token ref_id BIGINT Zarinpal reference ID amount NUMERIC(18,2) Payment amount status ENUM('initiated','verified','failed') DEFAULT 'initiated' Payment state created_at TIMESTAMP DEFAULT now() Payment start time verified_at TIMESTAMP Verification timestamp Indexes: idx_payments_authority and idx_payments_ref . 6. reports Stores aggregated data for dashboards and analytics. Column Type Description id SERIAL PK report_date DATE Date of aggregation total_users INT total_tickets INT active_loans INT total_volume NUMERIC(18,2) Indexes: idx_reports_date for quick historical queries. 7. notifications Tracks messages sent via SMS, WhatsApp, or email. Column Type Description id SERIAL PK user_id INT FK \u2192 users.id channel ENUM('sms','whatsapp','email') message TEXT status ENUM('queued','sent','failed') DEFAULT 'queued' created_at TIMESTAMP DEFAULT now() Relationships Summary Relationship Type Description users \u2192 wallets One-to-One Each user has one wallet users \u2192 tickets One-to-Many Users can create multiple tickets wallets \u2192 ledger_entries One-to-Many Each wallet has multiple transactions tickets \u2192 payments One-to-One Each ticket has one payment record users \u2192 notifications One-to-Many Users receive multiple notifications Database Management Notes Migrations handled via Django ORM and manage.py migrate . Backup and restore via pg_dump and pg_restore . Schema versioning via Django migration history. Foreign key constraints use ON DELETE CASCADE for dependent records. Regular vacuum and analyze scheduled for performance optimization.","title":"\ud83e\uddee Database Schema"},{"location":"database-schema/#database-schema-documentation","text":"","title":"Database Schema Documentation"},{"location":"database-schema/#overview","text":"This document defines the database schema for the Assets platform. It outlines all major tables, relationships, constraints, and indexing strategies. The platform uses PostgreSQL as the relational database engine, ensuring ACID compliance, foreign key integrity, and high scalability.","title":"Overview"},{"location":"database-schema/#core-design-principles","text":"Normalization: Third Normal Form (3NF) to reduce redundancy. Auditability: All wallet and ticket operations are logged. Security: Role-based access and Row-Level Security (RLS). Extensibility: Modular tables to support new features such as asset categories or payment gateways. Integrity: Foreign keys, constraints, and cascade rules ensure consistent data.","title":"Core Design Principles"},{"location":"database-schema/#entity-relationship-diagram-erd","text":"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 users \u2502\u2500\u2500\u2510 \u2502 tickets \u2502\u2500\u2500\u2510 \u2502 payments \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u25bc \u25bc \u25bc \u25bc \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 wallets \u2502 \u2502 ledger_entry \u2502 \u2502 reports \u2502 \u2502 notifications\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Entity Relationship Diagram (ERD)"},{"location":"database-schema/#table-definitions","text":"","title":"Table Definitions"},{"location":"database-schema/#1-users","text":"Stores registered user accounts and identity provider metadata. Column Type Constraints Description id SERIAL PK Unique user ID email VARCHAR(255) UNIQUE, NOT NULL Primary user identifier password VARCHAR(255) NULLABLE Encrypted password (for non-SSO users) first_name VARCHAR(100) User\u2019s first name last_name VARCHAR(100) User\u2019s last name role ENUM('admin','user') DEFAULT 'user' Role-based permissions sso_provider VARCHAR(50) OAuth2 provider name sso_sub VARCHAR(255) External provider subject ID created_at TIMESTAMP DEFAULT now() Creation timestamp updated_at TIMESTAMP DEFAULT now() Last profile update Indexes: idx_users_email for quick lookups. Unique composite index on (sso_provider, sso_sub) for federated users.","title":"1. users"},{"location":"database-schema/#2-wallets","text":"Each user owns one wallet, holding their balance in IRR (Rials). Column Type Constraints Description id SERIAL PK Wallet ID user_id INT FK \u2192 users.id Wallet owner balance NUMERIC(18,2) DEFAULT 0 Current balance currency VARCHAR(10) DEFAULT 'IRR' Currency code status ENUM('active','frozen') DEFAULT 'active' Wallet state created_at TIMESTAMP DEFAULT now() Creation timestamp Constraints: One wallet per user (UNIQUE user_id ). Indexes: idx_wallets_user for fast joins.","title":"2. wallets"},{"location":"database-schema/#3-ledger_entries","text":"Records every financial transaction for audit purposes (double-entry system). Column Type Constraints Description id SERIAL PK Ledger record ID wallet_id INT FK \u2192 wallets.id Related wallet type ENUM('credit','debit') Transaction direction amount NUMERIC(18,2) CHECK (amount > 0) Transaction amount ref VARCHAR(64) External reference (Zarinpal Ref ID) description TEXT Human-readable info created_at TIMESTAMP DEFAULT now() Time of entry created_by INT FK \u2192 users.id Who triggered it Indexes: idx_ledger_wallet on wallet_id . idx_ledger_ref for reconciliation with payment gateway.","title":"3. ledger_entries"},{"location":"database-schema/#4-tickets","text":"Handles asset lending requests and agreements. Column Type Constraints Description id SERIAL PK Ticket ID asset_name VARCHAR(255) NOT NULL Asset name or description borrower_id INT FK \u2192 users.id Borrower user lender_id INT FK \u2192 users.id Lender user price NUMERIC(18,2) Agreed rental price duration_days INT Duration of lending status ENUM('pending','accepted','active','completed','cancelled') DEFAULT 'pending' Ticket state created_at TIMESTAMP DEFAULT now() Creation timestamp updated_at TIMESTAMP DEFAULT now() Status change timestamp Indexes: idx_tickets_borrower_lender idx_tickets_status for admin dashboards.","title":"4. tickets"},{"location":"database-schema/#5-payments","text":"Tracks transactions made through Zarinpal. Column Type Constraints Description id SERIAL PK Payment record ID ticket_id INT FK \u2192 tickets.id Related ticket authority VARCHAR(64) UNIQUE Zarinpal authority token ref_id BIGINT Zarinpal reference ID amount NUMERIC(18,2) Payment amount status ENUM('initiated','verified','failed') DEFAULT 'initiated' Payment state created_at TIMESTAMP DEFAULT now() Payment start time verified_at TIMESTAMP Verification timestamp Indexes: idx_payments_authority and idx_payments_ref .","title":"5. payments"},{"location":"database-schema/#6-reports","text":"Stores aggregated data for dashboards and analytics. Column Type Description id SERIAL PK report_date DATE Date of aggregation total_users INT total_tickets INT active_loans INT total_volume NUMERIC(18,2) Indexes: idx_reports_date for quick historical queries.","title":"6. reports"},{"location":"database-schema/#7-notifications","text":"Tracks messages sent via SMS, WhatsApp, or email. Column Type Description id SERIAL PK user_id INT FK \u2192 users.id channel ENUM('sms','whatsapp','email') message TEXT status ENUM('queued','sent','failed') DEFAULT 'queued' created_at TIMESTAMP DEFAULT now()","title":"7. notifications"},{"location":"database-schema/#relationships-summary","text":"Relationship Type Description users \u2192 wallets One-to-One Each user has one wallet users \u2192 tickets One-to-Many Users can create multiple tickets wallets \u2192 ledger_entries One-to-Many Each wallet has multiple transactions tickets \u2192 payments One-to-One Each ticket has one payment record users \u2192 notifications One-to-Many Users receive multiple notifications","title":"Relationships Summary"},{"location":"database-schema/#database-management-notes","text":"Migrations handled via Django ORM and manage.py migrate . Backup and restore via pg_dump and pg_restore . Schema versioning via Django migration history. Foreign key constraints use ON DELETE CASCADE for dependent records. Regular vacuum and analyze scheduled for performance optimization.","title":"Database Management Notes"},{"location":"devops-deployment/","text":"DevOps & Deployment Overview The Assets project uses a monorepo architecture to manage both backend (Django) and frontend (Next.js) applications. This guide outlines the CI/CD workflows, environment configurations, Docker setup, and deployment strategies for production and staging environments. Goals Streamline deployment through automation. Maintain consistency between development, staging, and production. Ensure scalability, observability, and fault tolerance. Simplify developer onboarding via Dockerized environments. Repository Structure Assets/ \u251c\u2500\u2500 backend/ # Django + Django Ninja API \u251c\u2500\u2500 frontend/ # Next.js + HeroUI app \u251c\u2500\u2500 docs/ # Documentation for contributors \u251c\u2500\u2500 .github/workflows/ # CI/CD pipelines \u251c\u2500\u2500 compose.yml # Multi-service orchestration \u251c\u2500\u2500 .env.example # Sample environment file \u2514\u2500\u2500 Makefile # Common build and test commands CI/CD Workflow The project uses GitHub Actions for automated testing, linting, building, and deployment. Workflow Overview Pull Request Validation Lint backend and frontend code. Run unit and integration tests. Build & Push Docker Images Tag and push images to GHCR. Deploy to Production Trigger remote deployment. Environment Configuration All environment variables are centralized in the .env file. Docker Setup Both backend and frontend are containerized for consistent environments. Local Development Setup git clone https://github.com/shari-ar/Assets.git cd Assets cp .env.example .env docker-compose up --build Backend available at \u2192 http://localhost:8000 Frontend available at \u2192 http://localhost:3000 Common Commands make test # Run tests make format # Lint and format code make migrate # Run Django migrations make seed # Load seed data Deployment Targets Environment Platform Description Staging Local Docker Setup Preview deployments for QA Production VPS Available Online Monitoring & Logging Tool Purpose Sentry Application error tracking Prometheus Metrics collection Grafana Visualization and alerting Backup & Recovery Automated PostgreSQL backups using pg_dump . Daily snapshot retention policy for 30 days. Restore tested quarterly via CI scripts. Example Backup Script: pg_dump $DATABASE_URL > backup_$(date +%F).sql Security Considerations Use Nginx for reverse proxy. Use Docker secrets for credentials instead of plain .env . Enforce least privilege on database users. Enable firewall rules and VPC isolation . Use fail2ban or UFW for SSH protection. Auto-renew SSL certificates via Let\u2019s Encrypt . Future Improvements Horizontal scaling via Kubernetes. Zero-downtime migrations. Canary deployments and rollback automation. Terraform for infrastructure as code (IaC).","title":"\ud83e\udde0 DevOps & Deployment"},{"location":"devops-deployment/#devops-deployment","text":"","title":"DevOps &amp; Deployment"},{"location":"devops-deployment/#overview","text":"The Assets project uses a monorepo architecture to manage both backend (Django) and frontend (Next.js) applications. This guide outlines the CI/CD workflows, environment configurations, Docker setup, and deployment strategies for production and staging environments.","title":"Overview"},{"location":"devops-deployment/#goals","text":"Streamline deployment through automation. Maintain consistency between development, staging, and production. Ensure scalability, observability, and fault tolerance. Simplify developer onboarding via Dockerized environments.","title":"Goals"},{"location":"devops-deployment/#repository-structure","text":"Assets/ \u251c\u2500\u2500 backend/ # Django + Django Ninja API \u251c\u2500\u2500 frontend/ # Next.js + HeroUI app \u251c\u2500\u2500 docs/ # Documentation for contributors \u251c\u2500\u2500 .github/workflows/ # CI/CD pipelines \u251c\u2500\u2500 compose.yml # Multi-service orchestration \u251c\u2500\u2500 .env.example # Sample environment file \u2514\u2500\u2500 Makefile # Common build and test commands","title":"Repository Structure"},{"location":"devops-deployment/#cicd-workflow","text":"The project uses GitHub Actions for automated testing, linting, building, and deployment.","title":"CI/CD Workflow"},{"location":"devops-deployment/#workflow-overview","text":"Pull Request Validation Lint backend and frontend code. Run unit and integration tests. Build & Push Docker Images Tag and push images to GHCR. Deploy to Production Trigger remote deployment.","title":"Workflow Overview"},{"location":"devops-deployment/#environment-configuration","text":"All environment variables are centralized in the .env file.","title":"Environment Configuration"},{"location":"devops-deployment/#docker-setup","text":"Both backend and frontend are containerized for consistent environments.","title":"Docker Setup"},{"location":"devops-deployment/#local-development","text":"","title":"Local Development"},{"location":"devops-deployment/#setup","text":"git clone https://github.com/shari-ar/Assets.git cd Assets cp .env.example .env docker-compose up --build Backend available at \u2192 http://localhost:8000 Frontend available at \u2192 http://localhost:3000","title":"Setup"},{"location":"devops-deployment/#common-commands","text":"make test # Run tests make format # Lint and format code make migrate # Run Django migrations make seed # Load seed data","title":"Common Commands"},{"location":"devops-deployment/#deployment-targets","text":"Environment Platform Description Staging Local Docker Setup Preview deployments for QA Production VPS Available Online","title":"Deployment Targets"},{"location":"devops-deployment/#monitoring-logging","text":"Tool Purpose Sentry Application error tracking Prometheus Metrics collection Grafana Visualization and alerting","title":"Monitoring &amp; Logging"},{"location":"devops-deployment/#backup-recovery","text":"Automated PostgreSQL backups using pg_dump . Daily snapshot retention policy for 30 days. Restore tested quarterly via CI scripts. Example Backup Script: pg_dump $DATABASE_URL > backup_$(date +%F).sql","title":"Backup &amp; Recovery"},{"location":"devops-deployment/#security-considerations","text":"Use Nginx for reverse proxy. Use Docker secrets for credentials instead of plain .env . Enforce least privilege on database users. Enable firewall rules and VPC isolation . Use fail2ban or UFW for SSH protection. Auto-renew SSL certificates via Let\u2019s Encrypt .","title":"Security Considerations"},{"location":"devops-deployment/#future-improvements","text":"Horizontal scaling via Kubernetes. Zero-downtime migrations. Canary deployments and rollback automation. Terraform for infrastructure as code (IaC).","title":"Future Improvements"},{"location":"frontend/","text":"Frontend Overview The Assets frontend is a modern, responsive, and component-driven web application built with Next.js and HeroUI . It serves as the user interface for managing authentication, asset lending, ticket tracking, wallets, and dashboards. Tech Stack Category Technology Purpose Framework Next.js Server-side rendering (SSR) and routing UI Library HeroUI 2.8.x Modern responsive UI components State Management Zustand or React Context Global state handling for auth and wallet Styling Tailwind CSS Utility-first CSS framework Forms React Hook Form Form handling and validation Charts Recharts Data visualization for reports HTTP Client Axios Communication with Django Ninja API Notifications React Toastify Feedback and alerts Authentication JWT (via HttpOnly cookie) Secure session management Project Structure frontend/ \u251c\u2500\u2500 app/ \u2502 \u251c\u2500\u2500 (auth)/ # Auth-related pages (login, register, reset password) \u2502 \u251c\u2500\u2500 (dashboard)/ # User and admin dashboards \u2502 \u251c\u2500\u2500 (tickets)/ # Ticket management pages \u2502 \u251c\u2500\u2500 (wallet)/ # Wallet and transaction views \u2502 \u251c\u2500\u2500 layout.tsx # Global layout and header \u2502 \u2514\u2500\u2500 page.tsx # Default landing page \u251c\u2500\u2500 components/ \u2502 \u251c\u2500\u2500 ui/ # HeroUI component wrappers \u2502 \u251c\u2500\u2500 forms/ # Custom reusable form components \u2502 \u251c\u2500\u2500 dashboard/ # Widgets and charts \u2502 \u2514\u2500\u2500 shared/ # Common UI elements (Navbar, Footer, etc.) \u251c\u2500\u2500 hooks/ \u2502 \u2514\u2500\u2500 useAuth.ts # Auth helper hook \u251c\u2500\u2500 lib/ \u2502 \u251c\u2500\u2500 api.ts # Axios instance and interceptors \u2502 \u251c\u2500\u2500 auth.ts # JWT utilities \u2502 \u2514\u2500\u2500 config.ts # Global constants \u251c\u2500\u2500 public/ # Static assets \u251c\u2500\u2500 styles/ # Global and Tailwind CSS \u251c\u2500\u2500 types/ # TypeScript interfaces \u2514\u2500\u2500 package.json Routing & Pages Next.js App Router ( /app directory) handles routing. Each route corresponds to a logical module (e.g., /wallet , /tickets ). Dynamic routes (e.g., /tickets/[id] ) display detailed ticket info. Route Description / Landing page with overview and login/register buttons /auth/login User authentication page /auth/register Sign-up form (email/password) /dashboard Personalized user dashboard /wallet Wallet overview, transaction history, fund transfers /tickets List and manage user\u2019s asset lending requests /admin Admin dashboard (for admins only) API Integration All data is fetched from the Django Ninja API using the configured Axios client. Example API Client ( lib/api.ts ): import axios from \"axios\"; const api = axios.create({ baseURL: process.env.NEXT_PUBLIC_API_URL, withCredentials: true, }); api.interceptors.response.use( (response) => response, (error) => { if (error.response?.status === 401) { window.location.href = \"/auth/login\"; } return Promise.reject(error); } ); export default api; Example Usage: import api from \"@/lib/api\"; export async function fetchTickets() { const { data } = await api.get(\"/tickets/\"); return data; } Authentication Flow User logs in via /auth/login \u2192 backend issues JWT in an HttpOnly cookie. Auth state is persisted client-side using a secure API call to /users/me/ . Protected routes are wrapped in a RequireAuth higher-order component (HOC). Unauthorized users are redirected to /auth/login automatically. State Management Auth Context (Example): import { createContext, useContext, useState } from \"react\"; const AuthContext = createContext(null); export const AuthProvider = ({ children }) => { const [user, setUser] = useState(null); const login = async (email, password) => { const { data } = await api.post(\"/auth/login/\", { email, password }); setUser(data.user); }; return ( <AuthContext.Provider value={{ user, login }}> {children} </AuthContext.Provider> ); }; export const useAuth = () => useContext(AuthContext); UI Design Guidelines Color Palette: Neutral background, HeroUI primary theme, soft shadows, rounded corners. Typography: Vazirmatn font for readability. Layout: Responsive grid with sidebar navigation for dashboards. Accessibility & Dark Mode: Handled by HeroUI. Testing Type Tool Description Unit Tests Jest Component-level tests Integration Tests Playwright End-to-end testing of user flows Linting ESLint + Prettier Code quality enforcement Run all tests: npm run test Deployment Frontend is deployed via GHCR. Performance Optimization Static Rendering (SSG) for public pages. Incremental Static Regeneration (ISR) for dashboards. Dynamic Imports for heavy components. Image Optimization via Next.js <Image /> . Caching: HTTP-level caching for API responses. Future Enhancements Offline support with Service Workers. Progressive Web App (PWA) mode. Advanced animations with Framer Motion. Localization (i18n) for multi-language support. Component theming using CSS variables.","title":"\ud83e\ude84 Frontend"},{"location":"frontend/#frontend","text":"","title":"Frontend"},{"location":"frontend/#overview","text":"The Assets frontend is a modern, responsive, and component-driven web application built with Next.js and HeroUI . It serves as the user interface for managing authentication, asset lending, ticket tracking, wallets, and dashboards.","title":"Overview"},{"location":"frontend/#tech-stack","text":"Category Technology Purpose Framework Next.js Server-side rendering (SSR) and routing UI Library HeroUI 2.8.x Modern responsive UI components State Management Zustand or React Context Global state handling for auth and wallet Styling Tailwind CSS Utility-first CSS framework Forms React Hook Form Form handling and validation Charts Recharts Data visualization for reports HTTP Client Axios Communication with Django Ninja API Notifications React Toastify Feedback and alerts Authentication JWT (via HttpOnly cookie) Secure session management","title":"Tech Stack"},{"location":"frontend/#project-structure","text":"frontend/ \u251c\u2500\u2500 app/ \u2502 \u251c\u2500\u2500 (auth)/ # Auth-related pages (login, register, reset password) \u2502 \u251c\u2500\u2500 (dashboard)/ # User and admin dashboards \u2502 \u251c\u2500\u2500 (tickets)/ # Ticket management pages \u2502 \u251c\u2500\u2500 (wallet)/ # Wallet and transaction views \u2502 \u251c\u2500\u2500 layout.tsx # Global layout and header \u2502 \u2514\u2500\u2500 page.tsx # Default landing page \u251c\u2500\u2500 components/ \u2502 \u251c\u2500\u2500 ui/ # HeroUI component wrappers \u2502 \u251c\u2500\u2500 forms/ # Custom reusable form components \u2502 \u251c\u2500\u2500 dashboard/ # Widgets and charts \u2502 \u2514\u2500\u2500 shared/ # Common UI elements (Navbar, Footer, etc.) \u251c\u2500\u2500 hooks/ \u2502 \u2514\u2500\u2500 useAuth.ts # Auth helper hook \u251c\u2500\u2500 lib/ \u2502 \u251c\u2500\u2500 api.ts # Axios instance and interceptors \u2502 \u251c\u2500\u2500 auth.ts # JWT utilities \u2502 \u2514\u2500\u2500 config.ts # Global constants \u251c\u2500\u2500 public/ # Static assets \u251c\u2500\u2500 styles/ # Global and Tailwind CSS \u251c\u2500\u2500 types/ # TypeScript interfaces \u2514\u2500\u2500 package.json","title":"Project Structure"},{"location":"frontend/#routing-pages","text":"Next.js App Router ( /app directory) handles routing. Each route corresponds to a logical module (e.g., /wallet , /tickets ). Dynamic routes (e.g., /tickets/[id] ) display detailed ticket info. Route Description / Landing page with overview and login/register buttons /auth/login User authentication page /auth/register Sign-up form (email/password) /dashboard Personalized user dashboard /wallet Wallet overview, transaction history, fund transfers /tickets List and manage user\u2019s asset lending requests /admin Admin dashboard (for admins only)","title":"Routing &amp; Pages"},{"location":"frontend/#api-integration","text":"All data is fetched from the Django Ninja API using the configured Axios client. Example API Client ( lib/api.ts ): import axios from \"axios\"; const api = axios.create({ baseURL: process.env.NEXT_PUBLIC_API_URL, withCredentials: true, }); api.interceptors.response.use( (response) => response, (error) => { if (error.response?.status === 401) { window.location.href = \"/auth/login\"; } return Promise.reject(error); } ); export default api; Example Usage: import api from \"@/lib/api\"; export async function fetchTickets() { const { data } = await api.get(\"/tickets/\"); return data; }","title":"API Integration"},{"location":"frontend/#authentication-flow","text":"User logs in via /auth/login \u2192 backend issues JWT in an HttpOnly cookie. Auth state is persisted client-side using a secure API call to /users/me/ . Protected routes are wrapped in a RequireAuth higher-order component (HOC). Unauthorized users are redirected to /auth/login automatically.","title":"Authentication Flow"},{"location":"frontend/#state-management","text":"Auth Context (Example): import { createContext, useContext, useState } from \"react\"; const AuthContext = createContext(null); export const AuthProvider = ({ children }) => { const [user, setUser] = useState(null); const login = async (email, password) => { const { data } = await api.post(\"/auth/login/\", { email, password }); setUser(data.user); }; return ( <AuthContext.Provider value={{ user, login }}> {children} </AuthContext.Provider> ); }; export const useAuth = () => useContext(AuthContext);","title":"State Management"},{"location":"frontend/#ui-design-guidelines","text":"Color Palette: Neutral background, HeroUI primary theme, soft shadows, rounded corners. Typography: Vazirmatn font for readability. Layout: Responsive grid with sidebar navigation for dashboards. Accessibility & Dark Mode: Handled by HeroUI.","title":"UI Design Guidelines"},{"location":"frontend/#testing","text":"Type Tool Description Unit Tests Jest Component-level tests Integration Tests Playwright End-to-end testing of user flows Linting ESLint + Prettier Code quality enforcement Run all tests: npm run test","title":"Testing"},{"location":"frontend/#deployment","text":"Frontend is deployed via GHCR.","title":"Deployment"},{"location":"frontend/#performance-optimization","text":"Static Rendering (SSG) for public pages. Incremental Static Regeneration (ISR) for dashboards. Dynamic Imports for heavy components. Image Optimization via Next.js <Image /> . Caching: HTTP-level caching for API responses.","title":"Performance Optimization"},{"location":"frontend/#future-enhancements","text":"Offline support with Service Workers. Progressive Web App (PWA) mode. Advanced animations with Framer Motion. Localization (i18n) for multi-language support. Component theming using CSS variables.","title":"Future Enhancements"},{"location":"notifications-messaging/","text":"Notifications & Messaging Overview The Assets platform includes a comprehensive Notifications & Messaging subsystem that delivers real-time and asynchronous updates to users. It supports multiple communication channels\u2014 SMS , WhatsApp , and Email \u2014to ensure high engagement and transparency throughout the asset lending process. Goals Provide timely and reliable notifications to users. Support multi-channel delivery (SMS, WhatsApp, Email). Allow admin and automated system alerts. Enable retry mechanisms for failed messages. Maintain auditable logs for compliance and debugging. Features Multi-channel support (Email, SMS, WhatsApp). Configurable message templates with dynamic data. Centralized logging and retry on failure. Background job processing with Celery. Admin control for broadcasting messages. Notification Flow Event Triggered \u2013 A system action (e.g., payment verified, ticket approved) triggers a notification. Message Created \u2013 The backend generates a Notification record with placeholders and metadata. Queue Dispatch \u2013 Message is queued in Celery and sent asynchronously. Delivery Attempt \u2013 The appropriate adapter (SMS, WhatsApp, Email) processes and sends it. Status Update \u2013 On success or failure, the record is updated with a timestamp and provider response. Database Schema Column Type Description id SERIAL Primary key user_id INT (FK \u2192 users.id) Target recipient channel ENUM('sms', 'whatsapp', 'email') Delivery medium message TEXT Full message content status ENUM('queued','sent','failed') Delivery state created_at TIMESTAMP Time created sent_at TIMESTAMP Time sent error_log TEXT Error details if any Indexes: idx_notifications_user idx_notifications_status Message Templates Templates are stored as Markdown files and rendered with variables using Django\u2019s Template engine. Example Template ( templates/notifications/ticket_accepted.txt ): Hello {{ user.first_name }}, Your lending request for \"{{ ticket.asset_name }}\" has been accepted. The payment of {{ ticket.price }} IRR has been processed successfully. Ticket ID: {{ ticket.id }} Status: {{ ticket.status }} Thank you for using Assets Platform! Render Example: from django.template.loader import render_to_string message = render_to_string(\"notifications/ticket_accepted.txt\", { \"user\": user, \"ticket\": ticket }) Channels 1. Email Sent via Postmark . Supports HTML templates and attachments. Utilizes Django\u2019s built-in email backend with async wrappers. Example: from django.core.mail import send_mail send_mail( subject=\"Ticket Approved\", message=message_text, from_email=\"no-reply@assets.example.com\", recipient_list=[user.email] ) 2. SMS Integrates with sms.ir . Short messages for transaction and verification updates. Example SMS Payload: { \"receptor\": \"+989123456789\", \"message\": \"Your ticket #42 has been approved.\" } 3. WhatsApp Uses Twilio for message delivery. Supports template-based and custom messages. Requires verified business account and webhook setup. Example: import requests requests.post(\"https://graph.facebook.com/v17.0/<phone_id>/messages\", json={ \"messaging_product\": \"whatsapp\", \"to\": \"+989123456789\", \"type\": \"text\", \"text\": {\"body\": \"Your wallet has been credited with 100,000 IRR.\"} }) Configuration All notification services are configured via environment variables and Docker Secrets. Background Processing (Celery) Notifications are sent asynchronously to improve response times. Admin Interface Admins can resend failed notifications. Dashboard metrics display delivery rates and errors. Filters available for date, channel, and status. Testing Notifications Use Django\u2019s Email Backend Debug Mode for local testing: EMAIL_BACKEND = \"django.core.mail.backends.console.EmailBackend\" To test SMS and WhatsApp locally, mock provider APIs using responses . Logging & Monitoring All events stored in the notifications table. Failures logged in Django\u2019s log system and sent to Sentry . Prometheus metrics track delivery latency and failure rates. Example Metric Labels: notifications_sent_total{channel=\"email\"} notifications_failed_total{channel=\"sms\"} notifications_latency_seconds{channel=\"whatsapp\"} Future Enhancements Push notification support (Firebase Cloud Messaging). User preference center for notification settings. Delivery analytics dashboard. Multi-language template system. AI-based message personalization.","title":"\ud83d\udcf2 Notifications & Messaging"},{"location":"notifications-messaging/#notifications-messaging","text":"","title":"Notifications &amp; Messaging"},{"location":"notifications-messaging/#overview","text":"The Assets platform includes a comprehensive Notifications & Messaging subsystem that delivers real-time and asynchronous updates to users. It supports multiple communication channels\u2014 SMS , WhatsApp , and Email \u2014to ensure high engagement and transparency throughout the asset lending process.","title":"Overview"},{"location":"notifications-messaging/#goals","text":"Provide timely and reliable notifications to users. Support multi-channel delivery (SMS, WhatsApp, Email). Allow admin and automated system alerts. Enable retry mechanisms for failed messages. Maintain auditable logs for compliance and debugging.","title":"Goals"},{"location":"notifications-messaging/#features","text":"Multi-channel support (Email, SMS, WhatsApp). Configurable message templates with dynamic data. Centralized logging and retry on failure. Background job processing with Celery. Admin control for broadcasting messages.","title":"Features"},{"location":"notifications-messaging/#notification-flow","text":"Event Triggered \u2013 A system action (e.g., payment verified, ticket approved) triggers a notification. Message Created \u2013 The backend generates a Notification record with placeholders and metadata. Queue Dispatch \u2013 Message is queued in Celery and sent asynchronously. Delivery Attempt \u2013 The appropriate adapter (SMS, WhatsApp, Email) processes and sends it. Status Update \u2013 On success or failure, the record is updated with a timestamp and provider response.","title":"Notification Flow"},{"location":"notifications-messaging/#database-schema","text":"Column Type Description id SERIAL Primary key user_id INT (FK \u2192 users.id) Target recipient channel ENUM('sms', 'whatsapp', 'email') Delivery medium message TEXT Full message content status ENUM('queued','sent','failed') Delivery state created_at TIMESTAMP Time created sent_at TIMESTAMP Time sent error_log TEXT Error details if any Indexes: idx_notifications_user idx_notifications_status","title":"Database Schema"},{"location":"notifications-messaging/#message-templates","text":"Templates are stored as Markdown files and rendered with variables using Django\u2019s Template engine. Example Template ( templates/notifications/ticket_accepted.txt ): Hello {{ user.first_name }}, Your lending request for \"{{ ticket.asset_name }}\" has been accepted. The payment of {{ ticket.price }} IRR has been processed successfully. Ticket ID: {{ ticket.id }} Status: {{ ticket.status }} Thank you for using Assets Platform! Render Example: from django.template.loader import render_to_string message = render_to_string(\"notifications/ticket_accepted.txt\", { \"user\": user, \"ticket\": ticket })","title":"Message Templates"},{"location":"notifications-messaging/#channels","text":"","title":"Channels"},{"location":"notifications-messaging/#1-email","text":"Sent via Postmark . Supports HTML templates and attachments. Utilizes Django\u2019s built-in email backend with async wrappers. Example: from django.core.mail import send_mail send_mail( subject=\"Ticket Approved\", message=message_text, from_email=\"no-reply@assets.example.com\", recipient_list=[user.email] )","title":"1. Email"},{"location":"notifications-messaging/#2-sms","text":"Integrates with sms.ir . Short messages for transaction and verification updates. Example SMS Payload: { \"receptor\": \"+989123456789\", \"message\": \"Your ticket #42 has been approved.\" }","title":"2. SMS"},{"location":"notifications-messaging/#3-whatsapp","text":"Uses Twilio for message delivery. Supports template-based and custom messages. Requires verified business account and webhook setup. Example: import requests requests.post(\"https://graph.facebook.com/v17.0/<phone_id>/messages\", json={ \"messaging_product\": \"whatsapp\", \"to\": \"+989123456789\", \"type\": \"text\", \"text\": {\"body\": \"Your wallet has been credited with 100,000 IRR.\"} })","title":"3. WhatsApp"},{"location":"notifications-messaging/#configuration","text":"All notification services are configured via environment variables and Docker Secrets.","title":"Configuration"},{"location":"notifications-messaging/#background-processing-celery","text":"Notifications are sent asynchronously to improve response times.","title":"Background Processing (Celery)"},{"location":"notifications-messaging/#admin-interface","text":"Admins can resend failed notifications. Dashboard metrics display delivery rates and errors. Filters available for date, channel, and status.","title":"Admin Interface"},{"location":"notifications-messaging/#testing-notifications","text":"Use Django\u2019s Email Backend Debug Mode for local testing: EMAIL_BACKEND = \"django.core.mail.backends.console.EmailBackend\" To test SMS and WhatsApp locally, mock provider APIs using responses .","title":"Testing Notifications"},{"location":"notifications-messaging/#logging-monitoring","text":"All events stored in the notifications table. Failures logged in Django\u2019s log system and sent to Sentry . Prometheus metrics track delivery latency and failure rates. Example Metric Labels: notifications_sent_total{channel=\"email\"} notifications_failed_total{channel=\"sms\"} notifications_latency_seconds{channel=\"whatsapp\"}","title":"Logging &amp; Monitoring"},{"location":"notifications-messaging/#future-enhancements","text":"Push notification support (Firebase Cloud Messaging). User preference center for notification settings. Delivery analytics dashboard. Multi-language template system. AI-based message personalization.","title":"Future Enhancements"},{"location":"payment-integration/","text":"Payment Integration Overview This document describes the Zarinpal payment integration and wallet transaction flow used in the Assets platform. It ensures secure, auditable, and atomic payment operations across user wallets and the external payment gateway. Payment Gateway: Zarinpal The system uses Zarinpal to handle IRR (Iranian Rial) payments securely via HTTPS with merchant authentication. API Endpoints Sandbox (testing): https://sandbox.zarinpal.com/pg/v4/payment/ Production (live): https://api.zarinpal.com/pg/v4/payment/ Credentials & Config Environment Variable Purpose ZARINPAL_MERCHANT_ID Unique merchant identifier ZARINPAL_CALLBACK_URL URL where users are redirected post-payment ZARINPAL_MODE Either sandbox or production Integration Flow System sends a payment request with amount, description and callback URL. User is redirected to Zarinpal\u2019s payment page. After payment, user returns to callback URL with payment status & authority code. Backend calls Zarinpal\u2019s verification API to confirm the transaction. Based on the verification result, system mark the order as successful or failed. Payment Workflow 1. Initiate Transaction Trigger wallet_topup \u2014 activated when the user initiates a wallet recharge. Process User requests a wallet top-up from the frontend. Backend generates a unique order ID and records a pending transaction in the wallet ledger. A PaymentRequest is sent to Zarinpal , including the following data: Example Request { \"merchant_id\": \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\", \"amount\": 500000, \"description\": \"Wallet top-up for user #12\", \"callback_url\": \"https://{host}[:{port}]/api/v1/payments/verify/\", \"metadata\": { \"user_id\": 12, \"type\": \"wallet_topup\" } } Example Response { \"data\": { \"code\": 100, \"message\": \"Payment request accepted\", \"authority\": \"A00000000000000000000000000123456789\" } } The frontend redirects the user to Zarinpal\u2019s payment page using the authority code. 2. Verify Transaction (Callback) Once the user completes the payment, Zarinpal redirects to the callback URL with the following parameters: https://{host}[:{port}]/api/v1/payments/verify/?Authority=A00000000000000000000000000123456789&Status=OK The backend then verifies the payment through Zarinpal\u2019s /PaymentVerification API. Example Request { \"merchant_id\": \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\", \"amount\": 500000, \"authority\": \"A00000000000000000000000000123456789\" } Example Response { \"data\": { \"code\": 100, \"ref_id\": 987654321, \"message\": \"Transaction verified successfully\" } } Error Handling Code Meaning Recommended Action 100 Success Payment verified 101 Already Verified Ignore duplicate callback -9 Invalid Input Check parameters -22 Merchant Disabled Contact Zarinpal support -40 Invalid Merchant ID Verify environment configuration -54 Transaction Not Found Check authority code and amount All failures trigger notifications and log entries with the full response payload. Security Practices HMAC-SHA256 signatures used for request verification. All credentials are stored as environment variables and never committed to Git. Callback requests are validated by IP whitelisting and authority verification. Each payment request includes anti-replay nonce fields and timestamps. SSL/TLS enforced across all payment communications. Testing in Sandbox Mode Sandbox responses mimic live transactions and allow testing without real payments (Set ZARINPAL_SANDBOX=true in the environment). Example testing card: Card Number: 6104-3377-7777-7777 Password: 123 CVV2: 111 Expire Date: 12/1404 Reconciliation and Reporting Daily reconciliation compares local transactions with Zarinpal\u2019s report API. Mismatches trigger an automated alert and manual review task. Admin dashboard displays summary metrics: Total processed payments Failed/verifications pending Daily transaction volume Future Enhancements Add multi-gateway abstraction for supporting PayPing or IDPay. Integrate refund processing and partial settlements. Automate invoice generation and email confirmations. Expand payment webhooks for real-time notifications.","title":"\ud83d\udcb0 Payment Integration"},{"location":"payment-integration/#payment-integration","text":"","title":"Payment Integration"},{"location":"payment-integration/#overview","text":"This document describes the Zarinpal payment integration and wallet transaction flow used in the Assets platform. It ensures secure, auditable, and atomic payment operations across user wallets and the external payment gateway.","title":"Overview"},{"location":"payment-integration/#payment-gateway-zarinpal","text":"The system uses Zarinpal to handle IRR (Iranian Rial) payments securely via HTTPS with merchant authentication.","title":"Payment Gateway: Zarinpal"},{"location":"payment-integration/#api-endpoints","text":"Sandbox (testing): https://sandbox.zarinpal.com/pg/v4/payment/ Production (live): https://api.zarinpal.com/pg/v4/payment/","title":"API Endpoints"},{"location":"payment-integration/#credentials-config","text":"Environment Variable Purpose ZARINPAL_MERCHANT_ID Unique merchant identifier ZARINPAL_CALLBACK_URL URL where users are redirected post-payment ZARINPAL_MODE Either sandbox or production","title":"Credentials &amp; Config"},{"location":"payment-integration/#integration-flow","text":"System sends a payment request with amount, description and callback URL. User is redirected to Zarinpal\u2019s payment page. After payment, user returns to callback URL with payment status & authority code. Backend calls Zarinpal\u2019s verification API to confirm the transaction. Based on the verification result, system mark the order as successful or failed.","title":"Integration Flow"},{"location":"payment-integration/#payment-workflow","text":"","title":"Payment Workflow"},{"location":"payment-integration/#1-initiate-transaction","text":"","title":"1. Initiate Transaction"},{"location":"payment-integration/#trigger","text":"wallet_topup \u2014 activated when the user initiates a wallet recharge.","title":"Trigger"},{"location":"payment-integration/#process","text":"User requests a wallet top-up from the frontend. Backend generates a unique order ID and records a pending transaction in the wallet ledger. A PaymentRequest is sent to Zarinpal , including the following data: Example Request { \"merchant_id\": \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\", \"amount\": 500000, \"description\": \"Wallet top-up for user #12\", \"callback_url\": \"https://{host}[:{port}]/api/v1/payments/verify/\", \"metadata\": { \"user_id\": 12, \"type\": \"wallet_topup\" } } Example Response { \"data\": { \"code\": 100, \"message\": \"Payment request accepted\", \"authority\": \"A00000000000000000000000000123456789\" } } The frontend redirects the user to Zarinpal\u2019s payment page using the authority code.","title":"Process"},{"location":"payment-integration/#2-verify-transaction-callback","text":"Once the user completes the payment, Zarinpal redirects to the callback URL with the following parameters: https://{host}[:{port}]/api/v1/payments/verify/?Authority=A00000000000000000000000000123456789&Status=OK The backend then verifies the payment through Zarinpal\u2019s /PaymentVerification API. Example Request { \"merchant_id\": \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\", \"amount\": 500000, \"authority\": \"A00000000000000000000000000123456789\" } Example Response { \"data\": { \"code\": 100, \"ref_id\": 987654321, \"message\": \"Transaction verified successfully\" } }","title":"2. Verify Transaction (Callback)"},{"location":"payment-integration/#error-handling","text":"Code Meaning Recommended Action 100 Success Payment verified 101 Already Verified Ignore duplicate callback -9 Invalid Input Check parameters -22 Merchant Disabled Contact Zarinpal support -40 Invalid Merchant ID Verify environment configuration -54 Transaction Not Found Check authority code and amount All failures trigger notifications and log entries with the full response payload.","title":"Error Handling"},{"location":"payment-integration/#security-practices","text":"HMAC-SHA256 signatures used for request verification. All credentials are stored as environment variables and never committed to Git. Callback requests are validated by IP whitelisting and authority verification. Each payment request includes anti-replay nonce fields and timestamps. SSL/TLS enforced across all payment communications.","title":"Security Practices"},{"location":"payment-integration/#testing-in-sandbox-mode","text":"Sandbox responses mimic live transactions and allow testing without real payments (Set ZARINPAL_SANDBOX=true in the environment). Example testing card: Card Number: 6104-3377-7777-7777 Password: 123 CVV2: 111 Expire Date: 12/1404","title":"Testing in Sandbox Mode"},{"location":"payment-integration/#reconciliation-and-reporting","text":"Daily reconciliation compares local transactions with Zarinpal\u2019s report API. Mismatches trigger an automated alert and manual review task. Admin dashboard displays summary metrics: Total processed payments Failed/verifications pending Daily transaction volume","title":"Reconciliation and Reporting"},{"location":"payment-integration/#future-enhancements","text":"Add multi-gateway abstraction for supporting PayPing or IDPay. Integrate refund processing and partial settlements. Automate invoice generation and email confirmations. Expand payment webhooks for real-time notifications.","title":"Future Enhancements"},{"location":"roadmap/","text":"Project Roadmap Documented Capability Milestones Milestone Documented Capabilities Source Architecture Shell \u2192 Replace placeholder commands with real runtimes. Monorepo layout, TurboRepo structure, Docker Compose placeholders awaiting Django/Next.js apps. Architecture Documented Auth Flows \u2192 Implement JWT + OAuth endpoints. Email/password & OAuth login, refresh/logout, secure cookies, audit logging, security testing suite. Auth & Security Backend Blueprint \u2192 Scaffold Django project and domain apps. Planned Django + Ninja stack, app responsibilities (auth, wallet, tickets, payments, reports, notifications), enable migrations & Gunicorn. Backend Frontend Blueprint \u2192 Scaffold Next.js App Router experience. Next.js + HeroUI stack, planned routes ( /dashboard , /wallet , /tickets , /admin ), Zustand state, build commands. Frontend Database Schema \u2192 Materialize core tables and constraints. Users, wallets, ledger entries, tickets, payments, reports, notifications tables with indexes and RLS guidance. Database Schema API Surface \u2192 Ship Ninja routers matching documented contracts. Auth, users, wallet, ticket, report endpoints with example payloads and error handling. API Reference Reporting Stack \u2192 Build dashboards & exports pipeline. Role-based dashboards, Redis caching, aggregation jobs, CSV/PDF exports, performance considerations. Dashboards & Reporting Payment Rails \u2192 Integrate Zarinpal adapter with ledger sync. Zarinpal endpoints, initiation/verification flows, sandbox creds, error codes, reconciliation steps, HMAC signatures. Payment Integration Messaging Fabric \u2192 Stand up Celery-powered notifications. Multi-channel templates (SMS, WhatsApp, Email), retry logic, logging, admin broadcast tools, Prometheus metrics. Notifications & Messaging Role Enforcement \u2192 Enforce RBAC end-to-end. Admin/User roles, permission matrix, decorators, dashboard access rules, future roles. User Roles & Permissions Quality Gates \u2192 Automate testing strategy. PyTest, Django Test Client, Jest/RTL, Playwright, Locust, Bandit/Safety workflows, fixtures and coverage guidance. Testing Guide Operational Platform \u2192 Turn DevOps scaffolding into CI/CD. GitHub Actions blueprints, Docker images, environment secrets, monitoring stack, Terraform/Ansible roadmap. DevOps & Deployment Platform Cohesion \u2192 Align services with system design guardrails. Cross-service flows (auth, wallets, tickets), integration topology, scalability tactics, security principles. System Design Phase 1 \u2014 Core Runtime Bring-up Focus Based On Next Step Activate Architecture Shell Architecture, Backend, Frontend Generate Django + Next.js projects and switch Compose/Dockerfile commands to real runtimes. Stand up Auth & RBAC Auth & Security, User Roles & Permissions Build /auth/login , /auth/refresh , role-aware middlewares, and audit logging. Materialize Database Schema Database Schema Create migrations for users, wallets, tickets, payments, notifications with documented indexes. Phase 2 \u2014 Transaction & Data Foundations Focus Based On Next Step Deliver API Surface API Reference, System Design Implement Ninja routers for users, wallet, tickets, reports and align responses to documented contracts. Wire Payment Rails Payment Integration, Database Schema Build Zarinpal initiation/verification, ledger reconciliation, and failure handling. Enable Messaging Fabric Notifications & Messaging, System Design Launch Celery worker, channel adapters, and notification templates with retries. Phase 3 \u2014 Experience & Insight Focus Based On Next Step Launch Frontend Experience Frontend, API Reference Implement documented routes, state management, and API client wrappers to render live data. Build Reporting Stack Dashboards & Reporting, Database Schema Implement aggregation jobs, Redis caching, and export endpoints powering dashboards. Establish Quality Gates Testing Guide, DevOps & Deployment Enable automated lint/test pipelines, Playwright suite, and CI enforcement. Phase 4 \u2014 Operational Maturity Focus Based On Next Step Harden Operations DevOps & Deployment Turn placeholder GitHub Actions into deploy pipelines, configure monitoring stack, and document rollback drills. Scale & Secure Platform System Design, Auth & Security Apply scalability patterns, enforce encryption practices, and finalize incident response workflows. Close Reporting Feedback Loop Dashboards & Reporting, Testing Guide Add observability metrics, regression alerts, and usage analytics to refine product decisions.","title":"\ud83d\ude80 Roadmap"},{"location":"roadmap/#project-roadmap","text":"","title":"Project Roadmap"},{"location":"roadmap/#documented-capability-milestones","text":"Milestone Documented Capabilities Source Architecture Shell \u2192 Replace placeholder commands with real runtimes. Monorepo layout, TurboRepo structure, Docker Compose placeholders awaiting Django/Next.js apps. Architecture Documented Auth Flows \u2192 Implement JWT + OAuth endpoints. Email/password & OAuth login, refresh/logout, secure cookies, audit logging, security testing suite. Auth & Security Backend Blueprint \u2192 Scaffold Django project and domain apps. Planned Django + Ninja stack, app responsibilities (auth, wallet, tickets, payments, reports, notifications), enable migrations & Gunicorn. Backend Frontend Blueprint \u2192 Scaffold Next.js App Router experience. Next.js + HeroUI stack, planned routes ( /dashboard , /wallet , /tickets , /admin ), Zustand state, build commands. Frontend Database Schema \u2192 Materialize core tables and constraints. Users, wallets, ledger entries, tickets, payments, reports, notifications tables with indexes and RLS guidance. Database Schema API Surface \u2192 Ship Ninja routers matching documented contracts. Auth, users, wallet, ticket, report endpoints with example payloads and error handling. API Reference Reporting Stack \u2192 Build dashboards & exports pipeline. Role-based dashboards, Redis caching, aggregation jobs, CSV/PDF exports, performance considerations. Dashboards & Reporting Payment Rails \u2192 Integrate Zarinpal adapter with ledger sync. Zarinpal endpoints, initiation/verification flows, sandbox creds, error codes, reconciliation steps, HMAC signatures. Payment Integration Messaging Fabric \u2192 Stand up Celery-powered notifications. Multi-channel templates (SMS, WhatsApp, Email), retry logic, logging, admin broadcast tools, Prometheus metrics. Notifications & Messaging Role Enforcement \u2192 Enforce RBAC end-to-end. Admin/User roles, permission matrix, decorators, dashboard access rules, future roles. User Roles & Permissions Quality Gates \u2192 Automate testing strategy. PyTest, Django Test Client, Jest/RTL, Playwright, Locust, Bandit/Safety workflows, fixtures and coverage guidance. Testing Guide Operational Platform \u2192 Turn DevOps scaffolding into CI/CD. GitHub Actions blueprints, Docker images, environment secrets, monitoring stack, Terraform/Ansible roadmap. DevOps & Deployment Platform Cohesion \u2192 Align services with system design guardrails. Cross-service flows (auth, wallets, tickets), integration topology, scalability tactics, security principles. System Design","title":"Documented Capability Milestones"},{"location":"roadmap/#phase-1-core-runtime-bring-up","text":"Focus Based On Next Step Activate Architecture Shell Architecture, Backend, Frontend Generate Django + Next.js projects and switch Compose/Dockerfile commands to real runtimes. Stand up Auth & RBAC Auth & Security, User Roles & Permissions Build /auth/login , /auth/refresh , role-aware middlewares, and audit logging. Materialize Database Schema Database Schema Create migrations for users, wallets, tickets, payments, notifications with documented indexes.","title":"Phase 1 \u2014 Core Runtime Bring-up"},{"location":"roadmap/#phase-2-transaction-data-foundations","text":"Focus Based On Next Step Deliver API Surface API Reference, System Design Implement Ninja routers for users, wallet, tickets, reports and align responses to documented contracts. Wire Payment Rails Payment Integration, Database Schema Build Zarinpal initiation/verification, ledger reconciliation, and failure handling. Enable Messaging Fabric Notifications & Messaging, System Design Launch Celery worker, channel adapters, and notification templates with retries.","title":"Phase 2 \u2014 Transaction &amp; Data Foundations"},{"location":"roadmap/#phase-3-experience-insight","text":"Focus Based On Next Step Launch Frontend Experience Frontend, API Reference Implement documented routes, state management, and API client wrappers to render live data. Build Reporting Stack Dashboards & Reporting, Database Schema Implement aggregation jobs, Redis caching, and export endpoints powering dashboards. Establish Quality Gates Testing Guide, DevOps & Deployment Enable automated lint/test pipelines, Playwright suite, and CI enforcement.","title":"Phase 3 \u2014 Experience &amp; Insight"},{"location":"roadmap/#phase-4-operational-maturity","text":"Focus Based On Next Step Harden Operations DevOps & Deployment Turn placeholder GitHub Actions into deploy pipelines, configure monitoring stack, and document rollback drills. Scale & Secure Platform System Design, Auth & Security Apply scalability patterns, enforce encryption practices, and finalize incident response workflows. Close Reporting Feedback Loop Dashboards & Reporting, Testing Guide Add observability metrics, regression alerts, and usage analytics to refine product decisions.","title":"Phase 4 \u2014 Operational Maturity"},{"location":"system-design/","text":"System Design Specification 1. Purpose This document defines the system-level design for the Assets platform \u2014 a peer-to-peer asset lending system. It describes the overall architecture, functional modules, interactions, and scalability. 2. Goals and Principles Security first: Encrypted data flows, strict role boundaries, and auditable transactions. Extensibility: Modular services and replaceable adapters for payments, storage, and notifications. Performance: Efficient API responses and database queries under concurrent load. Reliability: Atomic transactions and safe wallet ledger operations. 3. High-Level Overview The system consists of five major components: Component Description Frontend Next.js + HeroUI web client for users and admins. Handles authentication, dashboards, and wallet/ticket interactions. API Gateway Django Ninja REST API providing all endpoints; handles auth, validation, and service routing. Core Services Logical modules: auth , wallet , tickets , reports . Each has its own models, serializers, and business logic. Database PostgreSQL with normalized schema and foreign keys. Enables strong consistency and auditability. Integrations Zarinpal for payments, SMS/WhatsApp for notifications, optional email services (Postmark/SendGrid). 4. Functional Flow 4.1 Authentication and Access User logs in via OAuth 2.0 (SSO) or email/password. Backend issues a JWT stored in an HttpOnly cookie. Frontend attaches the token to future requests. Role-based middleware enforces access (admin vs user). 4.2 Lending Workflow Borrower submits a ticket specifying asset, duration, and price. Lender receives a notification and accepts or declines. Once accepted, funds are reserved in borrower\u2019s wallet. Payment captured through Zarinpal and ledger entries created. Ticket status transitions: pending \u2192 accepted \u2192 active \u2192 completed . Post-loan, funds are settled and transaction logs updated. 4.3 Wallet and Payments Each user has one wallet in PostgreSQL. Double-entry ledger ensures all debits and credits are balanced. External payments handled by Zarinpal adapter , abstracted for future providers. Audit trail captures all wallet operations. 5. Data Flow Diagram +-----------+ +-------------+ +---------------+ +-------------+ | Browser | <----> | API Gateway | <----> | Core Services | <----> | PostgreSQL | | (Next.js) | | (Django) | | (Auth,Wallet, | | (RLS, Logs) | | | | | | Tickets...) | | | +-----------+ +-------------+ +---------------+ +-------------+ | | | | +--> Zarinpal, SMS, Email Integrations <------+ 6. Scalability and Deployment Area Approach Monorepo TurboRepo for shared code and consistent tooling. API Scaling Horizontal scaling behind load balancer; stateless JWT authentication. DB Optimization Indexing, query caching, and read replicas if necessary. Caching Redis for sessions, rate-limiting, and transient data. Static Assets Deployed via Vercel CDN for the frontend. 7. Security and Compliance Transport security: SSL/TLS enforced across all endpoints. Data at rest: AES-256 encryption for sensitive fields. Hashing: SHA-256 for integrity; bcrypt for passwords. Audit logging: Immutable logs for all wallet and admin actions. Compliance readiness: GDPR and data deletion policies. 8. Testing Strategy Layer Tool Coverage Backend PyTest, Django Test Client Unit + integration tests for all endpoints Frontend Playwright UI workflows and regression checks CI/CD GitHub Actions Lint, test, migrate, and deploy pipelines 9. Future Enhancements Multi-tenant organizations and team lending. Asset categories with images and metadata. Smart matching between lenders and borrowers. Reporting dashboards with time-series analytics. Optional blockchain-based escrow layer.","title":"\ud83e\uddf1 System Design Spec"},{"location":"system-design/#system-design-specification","text":"","title":"System Design Specification"},{"location":"system-design/#1-purpose","text":"This document defines the system-level design for the Assets platform \u2014 a peer-to-peer asset lending system. It describes the overall architecture, functional modules, interactions, and scalability.","title":"1. Purpose"},{"location":"system-design/#2-goals-and-principles","text":"Security first: Encrypted data flows, strict role boundaries, and auditable transactions. Extensibility: Modular services and replaceable adapters for payments, storage, and notifications. Performance: Efficient API responses and database queries under concurrent load. Reliability: Atomic transactions and safe wallet ledger operations.","title":"2. Goals and Principles"},{"location":"system-design/#3-high-level-overview","text":"The system consists of five major components: Component Description Frontend Next.js + HeroUI web client for users and admins. Handles authentication, dashboards, and wallet/ticket interactions. API Gateway Django Ninja REST API providing all endpoints; handles auth, validation, and service routing. Core Services Logical modules: auth , wallet , tickets , reports . Each has its own models, serializers, and business logic. Database PostgreSQL with normalized schema and foreign keys. Enables strong consistency and auditability. Integrations Zarinpal for payments, SMS/WhatsApp for notifications, optional email services (Postmark/SendGrid).","title":"3. High-Level Overview"},{"location":"system-design/#4-functional-flow","text":"","title":"4. Functional Flow"},{"location":"system-design/#41-authentication-and-access","text":"User logs in via OAuth 2.0 (SSO) or email/password. Backend issues a JWT stored in an HttpOnly cookie. Frontend attaches the token to future requests. Role-based middleware enforces access (admin vs user).","title":"4.1 Authentication and Access"},{"location":"system-design/#42-lending-workflow","text":"Borrower submits a ticket specifying asset, duration, and price. Lender receives a notification and accepts or declines. Once accepted, funds are reserved in borrower\u2019s wallet. Payment captured through Zarinpal and ledger entries created. Ticket status transitions: pending \u2192 accepted \u2192 active \u2192 completed . Post-loan, funds are settled and transaction logs updated.","title":"4.2 Lending Workflow"},{"location":"system-design/#43-wallet-and-payments","text":"Each user has one wallet in PostgreSQL. Double-entry ledger ensures all debits and credits are balanced. External payments handled by Zarinpal adapter , abstracted for future providers. Audit trail captures all wallet operations.","title":"4.3 Wallet and Payments"},{"location":"system-design/#5-data-flow-diagram","text":"+-----------+ +-------------+ +---------------+ +-------------+ | Browser | <----> | API Gateway | <----> | Core Services | <----> | PostgreSQL | | (Next.js) | | (Django) | | (Auth,Wallet, | | (RLS, Logs) | | | | | | Tickets...) | | | +-----------+ +-------------+ +---------------+ +-------------+ | | | | +--> Zarinpal, SMS, Email Integrations <------+","title":"5. Data Flow Diagram"},{"location":"system-design/#6-scalability-and-deployment","text":"Area Approach Monorepo TurboRepo for shared code and consistent tooling. API Scaling Horizontal scaling behind load balancer; stateless JWT authentication. DB Optimization Indexing, query caching, and read replicas if necessary. Caching Redis for sessions, rate-limiting, and transient data. Static Assets Deployed via Vercel CDN for the frontend.","title":"6. Scalability and Deployment"},{"location":"system-design/#7-security-and-compliance","text":"Transport security: SSL/TLS enforced across all endpoints. Data at rest: AES-256 encryption for sensitive fields. Hashing: SHA-256 for integrity; bcrypt for passwords. Audit logging: Immutable logs for all wallet and admin actions. Compliance readiness: GDPR and data deletion policies.","title":"7. Security and Compliance"},{"location":"system-design/#8-testing-strategy","text":"Layer Tool Coverage Backend PyTest, Django Test Client Unit + integration tests for all endpoints Frontend Playwright UI workflows and regression checks CI/CD GitHub Actions Lint, test, migrate, and deploy pipelines","title":"8. Testing Strategy"},{"location":"system-design/#9-future-enhancements","text":"Multi-tenant organizations and team lending. Asset categories with images and metadata. Smart matching between lenders and borrowers. Reporting dashboards with time-series analytics. Optional blockchain-based escrow layer.","title":"9. Future Enhancements"},{"location":"testing/","text":"Testing Guide Overview The Assets platform includes a comprehensive testing strategy to ensure the reliability, security, and correctness of both backend and frontend components. Testing is automated using PyTest , Django Test Client , and Playwright , with continuous integration handled through GitHub Actions. Goals Maintain high code quality through consistent automated tests. Validate API integrity and business logic correctness . Ensure frontend-backend integration remains stable. Catch regressions early via CI/CD pipelines. Testing Layers Layer Framework / Tool Description Unit Tests PyTest Test isolated functions and methods Integration Tests Django Test Client Verify API endpoints and DB transactions E2E Tests Playwright Simulate full user flows in browser Static Analysis Ruff / Bandit Linting and security checks Load Tests Locust Evaluate performance under stress Backend Testing 1. Unit Tests PyTest for lightweight, fast-running tests. Tests cover models, services, and utility functions. Example ( tests/test_wallet.py ): import pytest from apps.wallet.models import Wallet @pytest.mark.django_db def test_wallet_balance_update(): wallet = Wallet.objects.create(user_id=1, balance=100) wallet.balance += 50 wallet.save() assert wallet.balance == 150 Run all unit tests: pytest -v 2. Integration Tests Integration tests use Django Test Client to simulate API requests. Example ( tests/test_tickets.py ): from django.test import Client def test_create_ticket(): client = Client() client.login(email=\"user@example.com\", password=\"1234\") response = client.post(\"/api/v1/tickets/\", {\"asset_name\": \"Camera\", \"price\": 100, \"duration_days\": 5}) assert response.status_code == 200 Run integration tests with: pytest tests/ --disable-warnings Frontend Testing 1. Unit & Component Tests Tool: Jest + React Testing Library Tests verify rendering, props, and user interactions. Example: import { render, screen } from \"@testing-library/react\"; import WalletCard from \"@/components/dashboard/WalletCard\"; test(\"renders wallet balance\", () => { render(<WalletCard balance={1000} />); expect(screen.getByText(\"1000\")).toBeInTheDocument(); }); Run frontend tests: npm run test 2. End-to-End (E2E) Tests Tool: Playwright Simulates real browser interactions. Example Scenario: User logs in. Creates a new lending ticket. Completes payment flow. Example Test ( tests/e2e/login.spec.ts ): import { test, expect } from \"@playwright/test\"; test(\"user can log in\", async ({ page }) => { await page.goto(\"http://localhost:3000/auth/login\"); await page.fill(\"input[name=email]\", \"user@example.com\"); await page.fill(\"input[name=password]\", \"1234\"); await page.click(\"button[type=submit]\"); await expect(page).toHaveURL(\"/dashboard\"); }); Run E2E tests: npx playwright test Continuous Integration (CI) GitHub Actions automatically runs tests on each pull request. Example Workflow ( .github/workflows/test.yml ): name: CI Tests on: [push, pull_request] jobs: test: runs-on: ubuntu-latest services: postgres: image: postgres:15 env: POSTGRES_DB: assets POSTGRES_USER: user POSTGRES_PASSWORD: pass ports: - 5432:5432 steps: - uses: actions/checkout@v3 - name: Set up Python uses: actions/setup-python@v4 with: python-version: 3.11 - name: Install dependencies run: | pip install -r backend/requirements.txt npm ci --prefix frontend - name: Run Backend Tests run: pytest backend/tests/ - name: Run Frontend Tests run: npm test --prefix frontend Test Data and Fixtures Seed Data Seed scripts provide initial data for consistent test environments. Command: python manage.py loaddata seed_data.json PyTest Fixtures Reusable components for user creation, wallet initialization, and ticket seeding. Example: @pytest.fixture def user(db, django_user_model): return django_user_model.objects.create_user(email=\"user@example.com\", password=\"1234\") Performance & Load Testing Use Locust for concurrent user simulations. Example: from locust import HttpUser, task class AssetsUser(HttpUser): @task def view_dashboard(self): self.client.get(\"/api/v1/reports/overview/\") Run load test: locust -f locustfile.py Security Testing Tool Purpose Bandit Detect insecure Python code Safety Check dependencies for known vulnerabilities OWASP ZAP Automated web security scanning Example command: bandit -r backend/ safety check -r backend/requirements.txt Coverage Reports Generate test coverage reports to ensure code completeness. pytest --cov=apps --cov-report=html View results in htmlcov/index.html . Checklist Test both happy and failure paths. Keep tests idempotent and independent . Use factory methods for repeatable data creation. Run tests before each deployment. Use GitHub badges to display CI test status.","title":"\ud83d\udd0d Testing"},{"location":"testing/#testing-guide","text":"","title":"Testing Guide"},{"location":"testing/#overview","text":"The Assets platform includes a comprehensive testing strategy to ensure the reliability, security, and correctness of both backend and frontend components. Testing is automated using PyTest , Django Test Client , and Playwright , with continuous integration handled through GitHub Actions.","title":"Overview"},{"location":"testing/#goals","text":"Maintain high code quality through consistent automated tests. Validate API integrity and business logic correctness . Ensure frontend-backend integration remains stable. Catch regressions early via CI/CD pipelines.","title":"Goals"},{"location":"testing/#testing-layers","text":"Layer Framework / Tool Description Unit Tests PyTest Test isolated functions and methods Integration Tests Django Test Client Verify API endpoints and DB transactions E2E Tests Playwright Simulate full user flows in browser Static Analysis Ruff / Bandit Linting and security checks Load Tests Locust Evaluate performance under stress","title":"Testing Layers"},{"location":"testing/#backend-testing","text":"","title":"Backend Testing"},{"location":"testing/#1-unit-tests","text":"PyTest for lightweight, fast-running tests. Tests cover models, services, and utility functions. Example ( tests/test_wallet.py ): import pytest from apps.wallet.models import Wallet @pytest.mark.django_db def test_wallet_balance_update(): wallet = Wallet.objects.create(user_id=1, balance=100) wallet.balance += 50 wallet.save() assert wallet.balance == 150 Run all unit tests: pytest -v","title":"1. Unit Tests"},{"location":"testing/#2-integration-tests","text":"Integration tests use Django Test Client to simulate API requests. Example ( tests/test_tickets.py ): from django.test import Client def test_create_ticket(): client = Client() client.login(email=\"user@example.com\", password=\"1234\") response = client.post(\"/api/v1/tickets/\", {\"asset_name\": \"Camera\", \"price\": 100, \"duration_days\": 5}) assert response.status_code == 200 Run integration tests with: pytest tests/ --disable-warnings","title":"2. Integration Tests"},{"location":"testing/#frontend-testing","text":"","title":"Frontend Testing"},{"location":"testing/#1-unit-component-tests","text":"Tool: Jest + React Testing Library Tests verify rendering, props, and user interactions. Example: import { render, screen } from \"@testing-library/react\"; import WalletCard from \"@/components/dashboard/WalletCard\"; test(\"renders wallet balance\", () => { render(<WalletCard balance={1000} />); expect(screen.getByText(\"1000\")).toBeInTheDocument(); }); Run frontend tests: npm run test","title":"1. Unit &amp; Component Tests"},{"location":"testing/#2-end-to-end-e2e-tests","text":"Tool: Playwright Simulates real browser interactions. Example Scenario: User logs in. Creates a new lending ticket. Completes payment flow. Example Test ( tests/e2e/login.spec.ts ): import { test, expect } from \"@playwright/test\"; test(\"user can log in\", async ({ page }) => { await page.goto(\"http://localhost:3000/auth/login\"); await page.fill(\"input[name=email]\", \"user@example.com\"); await page.fill(\"input[name=password]\", \"1234\"); await page.click(\"button[type=submit]\"); await expect(page).toHaveURL(\"/dashboard\"); }); Run E2E tests: npx playwright test","title":"2. End-to-End (E2E) Tests"},{"location":"testing/#continuous-integration-ci","text":"GitHub Actions automatically runs tests on each pull request. Example Workflow ( .github/workflows/test.yml ): name: CI Tests on: [push, pull_request] jobs: test: runs-on: ubuntu-latest services: postgres: image: postgres:15 env: POSTGRES_DB: assets POSTGRES_USER: user POSTGRES_PASSWORD: pass ports: - 5432:5432 steps: - uses: actions/checkout@v3 - name: Set up Python uses: actions/setup-python@v4 with: python-version: 3.11 - name: Install dependencies run: | pip install -r backend/requirements.txt npm ci --prefix frontend - name: Run Backend Tests run: pytest backend/tests/ - name: Run Frontend Tests run: npm test --prefix frontend","title":"Continuous Integration (CI)"},{"location":"testing/#test-data-and-fixtures","text":"","title":"Test Data and Fixtures"},{"location":"testing/#seed-data","text":"Seed scripts provide initial data for consistent test environments. Command: python manage.py loaddata seed_data.json","title":"Seed Data"},{"location":"testing/#pytest-fixtures","text":"Reusable components for user creation, wallet initialization, and ticket seeding. Example: @pytest.fixture def user(db, django_user_model): return django_user_model.objects.create_user(email=\"user@example.com\", password=\"1234\")","title":"PyTest Fixtures"},{"location":"testing/#performance-load-testing","text":"Use Locust for concurrent user simulations. Example: from locust import HttpUser, task class AssetsUser(HttpUser): @task def view_dashboard(self): self.client.get(\"/api/v1/reports/overview/\") Run load test: locust -f locustfile.py","title":"Performance &amp; Load Testing"},{"location":"testing/#security-testing","text":"Tool Purpose Bandit Detect insecure Python code Safety Check dependencies for known vulnerabilities OWASP ZAP Automated web security scanning Example command: bandit -r backend/ safety check -r backend/requirements.txt","title":"Security Testing"},{"location":"testing/#coverage-reports","text":"Generate test coverage reports to ensure code completeness. pytest --cov=apps --cov-report=html View results in htmlcov/index.html .","title":"Coverage Reports"},{"location":"testing/#checklist","text":"Test both happy and failure paths. Keep tests idempotent and independent . Use factory methods for repeatable data creation. Run tests before each deployment. Use GitHub badges to display CI test status.","title":"Checklist"},{"location":"user-roles-permissions/","text":"User Roles & Permissions Overview The Assets platform implements a robust role-based access control (RBAC) system to ensure that users have access only to authorized functionality. This guide explains the available roles, permission hierarchies, and enforcement mechanisms within the backend and frontend applications. Goals Protect sensitive operations from unauthorized access. Simplify permission management for users and admins. Support future scalability (e.g., team-based or organization-based roles). Enforce the principle of least privilege. Core Roles Role Description Typical Actions Admin Platform administrator with full privileges. Manage users and generate reports. User Standard authenticated user. Create and manage their own tickets, use wallet, view reports. Role Hierarchy Admin \u2514\u2500\u2500 User Admins have read access to all resources. Users have access only to their own data and limited public endpoints. Future roles (e.g., moderator , auditor ) can extend this hierarchy. Permission Matrix Module Action User Admin Authentication Register/Login \u2705 \u2705 Tickets Create/Update/Delete Own \u2705 \u2705 Tickets Read Any \u274c \u2705 Wallet View/Manage Own \u2705 \u2705 Wallet Reads Others\u2019 Wallets \u274c \u2705 Reports View Personal Reports \u2705 \u2705 Reports Access All Reports \u274c \u2705 Notifications Receive \u2705 \u2705 Notifications Broadcast \u274c \u2705 Admin Dashboard Access \u274c \u2705 \u2705 = Allowed | \u274c = Restricted API Role Enforcement All API routes define permission decorators or dependencies. Decorator Description @login_required Requires authentication. @admin_required Restricts access to admin-only endpoints. Admin Dashboard Permissions The admin dashboard is accessible only to users with the admin role. It allows the following operations: View all users and wallets. Generate and export financial reports. Broadcast notifications to all users. Security Considerations Tokens include user role claims ( role=admin or role=user ). Backend authorization always takes precedence over frontend visibility. Sensitive endpoints enforce both JWT validation and role checks . Logs include user ID and role for every API call. Attempted access violations are recorded for audit. Future Role Extensions Planned Role Description Moderator Manage and verify asset listings. Auditor Read-only access to financial reports and logs. Support Agent Handle ticket and user inquiries via support dashboard. Testing Permissions Example Tests: def test_user_cannot_access_admin_endpoints(client, user): client.force_authenticate(user) response = client.get(\"/api/v1/admin/reports/\") assert response.status_code == 403 def test_admin_can_access_reports(client, admin_user): client.force_authenticate(admin_user) response = client.get(\"/api/v1/admin/reports/\") assert response.status_code == 200 Summary Component Enforcement Location JWT & OAuth Tokens Authentication Layer Role Checks Middleware and Endpoints UI Restrictions Frontend Components Database Filters Querysets and Repositories Together, these ensure that data access is consistent, secure, and auditable across the entire system.","title":"\ud83d\udc65 User Roles & Permissions"},{"location":"user-roles-permissions/#user-roles-permissions","text":"","title":"User Roles &amp; Permissions"},{"location":"user-roles-permissions/#overview","text":"The Assets platform implements a robust role-based access control (RBAC) system to ensure that users have access only to authorized functionality. This guide explains the available roles, permission hierarchies, and enforcement mechanisms within the backend and frontend applications.","title":"Overview"},{"location":"user-roles-permissions/#goals","text":"Protect sensitive operations from unauthorized access. Simplify permission management for users and admins. Support future scalability (e.g., team-based or organization-based roles). Enforce the principle of least privilege.","title":"Goals"},{"location":"user-roles-permissions/#core-roles","text":"Role Description Typical Actions Admin Platform administrator with full privileges. Manage users and generate reports. User Standard authenticated user. Create and manage their own tickets, use wallet, view reports.","title":"Core Roles"},{"location":"user-roles-permissions/#role-hierarchy","text":"Admin \u2514\u2500\u2500 User Admins have read access to all resources. Users have access only to their own data and limited public endpoints. Future roles (e.g., moderator , auditor ) can extend this hierarchy.","title":"Role Hierarchy"},{"location":"user-roles-permissions/#permission-matrix","text":"Module Action User Admin Authentication Register/Login \u2705 \u2705 Tickets Create/Update/Delete Own \u2705 \u2705 Tickets Read Any \u274c \u2705 Wallet View/Manage Own \u2705 \u2705 Wallet Reads Others\u2019 Wallets \u274c \u2705 Reports View Personal Reports \u2705 \u2705 Reports Access All Reports \u274c \u2705 Notifications Receive \u2705 \u2705 Notifications Broadcast \u274c \u2705 Admin Dashboard Access \u274c \u2705 \u2705 = Allowed | \u274c = Restricted","title":"Permission Matrix"},{"location":"user-roles-permissions/#api-role-enforcement","text":"All API routes define permission decorators or dependencies. Decorator Description @login_required Requires authentication. @admin_required Restricts access to admin-only endpoints.","title":"API Role Enforcement"},{"location":"user-roles-permissions/#admin-dashboard-permissions","text":"The admin dashboard is accessible only to users with the admin role. It allows the following operations: View all users and wallets. Generate and export financial reports. Broadcast notifications to all users.","title":"Admin Dashboard Permissions"},{"location":"user-roles-permissions/#security-considerations","text":"Tokens include user role claims ( role=admin or role=user ). Backend authorization always takes precedence over frontend visibility. Sensitive endpoints enforce both JWT validation and role checks . Logs include user ID and role for every API call. Attempted access violations are recorded for audit.","title":"Security Considerations"},{"location":"user-roles-permissions/#future-role-extensions","text":"Planned Role Description Moderator Manage and verify asset listings. Auditor Read-only access to financial reports and logs. Support Agent Handle ticket and user inquiries via support dashboard.","title":"Future Role Extensions"},{"location":"user-roles-permissions/#testing-permissions","text":"Example Tests: def test_user_cannot_access_admin_endpoints(client, user): client.force_authenticate(user) response = client.get(\"/api/v1/admin/reports/\") assert response.status_code == 403 def test_admin_can_access_reports(client, admin_user): client.force_authenticate(admin_user) response = client.get(\"/api/v1/admin/reports/\") assert response.status_code == 200","title":"Testing Permissions"},{"location":"user-roles-permissions/#summary","text":"Component Enforcement Location JWT & OAuth Tokens Authentication Layer Role Checks Middleware and Endpoints UI Restrictions Frontend Components Database Filters Querysets and Repositories Together, these ensure that data access is consistent, secure, and auditable across the entire system.","title":"Summary"}]}